# æ•¸æ“šæ ¼å¼å¯¦ç¾åƒè€ƒ

æœ¬æ–‡æª”æä¾›æ•¸æ“šæ ¼å¼çš„å¯¦ç¾ç¯„ä¾‹å’Œå·¥å…·å‡½æ•¸ã€‚

---

## ğŸ“¦ Python å¯¦ç¾ç¯„ä¾‹

### 1. æ•¸æ“šåŒ…ç·¨ç¢¼/è§£ç¢¼é¡

```python
import struct
from enum import IntEnum
from typing import Optional, Tuple, Any

class DataType(IntEnum):
    """æ•¸æ“šé¡å‹IDæšèˆ‰"""
    # è¼‰å…· â†’ ä¸­æ§
    HEARTBEAT = 0x0101
    ATTITUDE = 0x0102
    MOTION = 0x0103
    GPS = 0x0104
    ALTITUDE = 0x0105
    BATTERY = 0x0201
    CHARGING_STATUS = 0x0202
    SYSTEM_LOAD = 0x0301
    LOG_MESSAGE = 0x0302
    CAMERA_STATUS = 0x0303
    CAMERA_FRAME = 0x0401
    
    # ä¸­æ§ â†’ è¼‰å…·
    GCS_HEARTBEAT = 0x1001
    ARM_COMMAND = 0x1002
    SET_MODE = 0x1003
    SET_HOME = 0x1004
    RC_OVERRIDE = 0x1005
    SET_WAYPOINT = 0x1101
    MISSION_CONTROL = 0x1102
    WAYPOINT_QUERY = 0x1103
    GOTO_LOCATION = 0x1104
    VEHICLE_POSITION = 0x1201
    
    # å›æ‡‰
    COMMAND_ACK = 0x1080
    WAYPOINT_LIST = 0x1083

class DeviceID(IntEnum):
    """è¨­å‚™IDæšèˆ‰"""
    GCS = 0x01      # ä¸­æ§
    UAV = 0x02      # ç„¡äººæ©Ÿ
    UGV = 0x03      # ç„¡äººè»Š
    BROADCAST = 0xFF # å»£æ’­

class PacketCodec:
    """æ•¸æ“šåŒ…ç·¨ç¢¼è§£ç¢¼å™¨"""
    
    HEADER_BYTE = 0xFF
    FOOTER_BYTE = 0xFE
    VERSION = 0x01
    
    @staticmethod
    def crc16_ccitt(data: bytes) -> int:
        """è¨ˆç®—CRC16-CCITTæ ¡é©—ç¢¼"""
        crc = 0xFFFF
        for byte in data:
            crc ^= byte << 8
            for _ in range(8):
                if crc & 0x8000:
                    crc = (crc << 1) ^ 0x1021
                else:
                    crc = crc << 1
                crc &= 0xFFFF
        return crc
    
    @staticmethod
    def encode(source: DeviceID, target: DeviceID, data_type: DataType, 
               payload: bytes) -> bytes:
        """
        ç·¨ç¢¼æ•¸æ“šåŒ…
        
        Args:
            source: ä¾†æºè¨­å‚™ID
            target: ç›®æ¨™è¨­å‚™ID
            data_type: æ•¸æ“šé¡å‹ID
            payload: æ•¸æ“šè¼‰è·
            
        Returns:
            å®Œæ•´çš„æ•¸æ“šåŒ…
        """
        # æ§‹å»ºåŒ…é ­ï¼ˆä¸å«èµ·å§‹æ¨™è­˜ï¼‰
        header = struct.pack('<BBBBHH',
            PacketCodec.VERSION,  # ç‰ˆæœ¬
            source,               # ä¾†æº
            target,               # ç›®æ¨™
            data_type & 0xFF,     # æ•¸æ“šé¡å‹ä½å­—ç¯€
            data_type >> 8,       # æ•¸æ“šé¡å‹é«˜å­—ç¯€
            len(payload)          # æ•¸æ“šé•·åº¦
        )
        
        # è¨ˆç®—CRCï¼ˆå¾ç‰ˆæœ¬åˆ°æ•¸æ“šè¼‰è·ï¼‰
        crc_data = header + payload
        crc = PacketCodec.crc16_ccitt(crc_data)
        
        # çµ„è£å®Œæ•´æ•¸æ“šåŒ…
        packet = struct.pack('B', PacketCodec.HEADER_BYTE)  # èµ·å§‹
        packet += crc_data                                    # åŒ…é ­+è¼‰è·
        packet += struct.pack('<H', crc)                     # CRC
        packet += struct.pack('B', PacketCodec.FOOTER_BYTE)  # çµæŸ
        
        return packet
    
    @staticmethod
    def decode(packet: bytes) -> Optional[Tuple[DeviceID, DeviceID, DataType, bytes]]:
        """
        è§£ç¢¼æ•¸æ“šåŒ…
        
        Args:
            packet: åŸå§‹æ•¸æ“šåŒ…
            
        Returns:
            (source, target, data_type, payload) æˆ– Noneï¼ˆå¦‚æœæ ¡é©—å¤±æ•—ï¼‰
        """
        if len(packet) < 11:  # æœ€å°åŒ…é•·
            return None
            
        # æª¢æŸ¥èµ·å§‹å’ŒçµæŸæ¨™è­˜
        if packet[0] != PacketCodec.HEADER_BYTE or packet[-1] != PacketCodec.FOOTER_BYTE:
            return None
        
        # è§£æåŒ…é ­
        version, source, target, type_low, type_high, length = struct.unpack(
            '<BBBBHH', packet[1:9]
        )
        
        if version != PacketCodec.VERSION:
            return None
        
        data_type = (type_high << 8) | type_low
        
        # æå–è¼‰è·
        payload = packet[9:9+length]
        
        # é©—è­‰CRC
        crc_expected = struct.unpack('<H', packet[9+length:11+length])[0]
        crc_actual = PacketCodec.crc16_ccitt(packet[1:9+length])
        
        if crc_expected != crc_actual:
            return None
        
        return (DeviceID(source), DeviceID(target), DataType(data_type), payload)


# ========== æ•¸æ“šçµæ§‹å®šç¾© ==========

class Heartbeat:
    """å¿ƒè·³åŒ…æ•¸æ“šçµæ§‹"""
    
    FORMAT = '<IBBBB'
    SIZE = 8
    
    def __init__(self, timestamp: int, armed: bool, mode: int, 
                 system_status: int, online: bool):
        self.timestamp = timestamp
        self.armed = armed
        self.mode = mode
        self.system_status = system_status
        self.online = online
    
    def encode(self) -> bytes:
        """ç·¨ç¢¼ç‚ºå­—ç¯€"""
        return struct.pack(self.FORMAT, 
            self.timestamp,
            1 if self.armed else 0,
            self.mode,
            self.system_status,
            1 if self.online else 0
        )
    
    @classmethod
    def decode(cls, data: bytes) -> 'Heartbeat':
        """å¾å­—ç¯€è§£ç¢¼"""
        timestamp, armed, mode, status, online = struct.unpack(cls.FORMAT, data)
        return cls(timestamp, bool(armed), mode, status, bool(online))
    
    def to_dict(self) -> dict:
        """è½‰æ›ç‚ºå­—å…¸"""
        return {
            'timestamp': self.timestamp,
            'armed': self.armed,
            'mode': self.mode,
            'system_status': self.system_status,
            'online': self.online
        }


class Attitude:
    """å§¿æ…‹æ•¸æ“šçµæ§‹"""
    
    FORMAT = '<Iffffff'
    SIZE = 28
    
    def __init__(self, timestamp: int, roll: float, pitch: float, yaw: float,
                 roll_speed: float, pitch_speed: float, yaw_speed: float):
        self.timestamp = timestamp
        self.roll = roll
        self.pitch = pitch
        self.yaw = yaw
        self.roll_speed = roll_speed
        self.pitch_speed = pitch_speed
        self.yaw_speed = yaw_speed
    
    def encode(self) -> bytes:
        return struct.pack(self.FORMAT,
            self.timestamp, self.roll, self.pitch, self.yaw,
            self.roll_speed, self.pitch_speed, self.yaw_speed
        )
    
    @classmethod
    def decode(cls, data: bytes) -> 'Attitude':
        values = struct.unpack(cls.FORMAT, data)
        return cls(*values)
    
    def to_dict(self) -> dict:
        import math
        return {
            'timestamp': self.timestamp,
            'roll': self.roll,
            'pitch': self.pitch,
            'yaw': self.yaw,
            'roll_deg': math.degrees(self.roll),
            'pitch_deg': math.degrees(self.pitch),
            'yaw_deg': math.degrees(self.yaw),
            'roll_speed': self.roll_speed,
            'pitch_speed': self.pitch_speed,
            'yaw_speed': self.yaw_speed
        }


class GPS:
    """GPSæ•¸æ“šçµæ§‹"""
    
    FORMAT = '<IddffBBH'
    SIZE = 28
    
    def __init__(self, timestamp: int, latitude: float, longitude: float,
                 altitude: float, fix_type: int, satellites: int, hdop: int):
        self.timestamp = timestamp
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude
        self.fix_type = fix_type
        self.satellites = satellites
        self.hdop = hdop
    
    def encode(self) -> bytes:
        return struct.pack(self.FORMAT,
            self.timestamp, self.latitude, self.longitude, self.altitude,
            self.fix_type, self.satellites, self.hdop
        )
    
    @classmethod
    def decode(cls, data: bytes) -> 'GPS':
        values = struct.unpack(cls.FORMAT, data)
        return cls(*values)
    
    def to_dict(self) -> dict:
        return {
            'timestamp': self.timestamp,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'altitude': self.altitude,
            'fix_type': self.fix_type,
            'satellites': self.satellites,
            'hdop': self.hdop / 100.0  # è½‰æ›ç‚ºå¯¦éš›å€¼
        }


class SetWaypoint:
    """è¨­å®šèˆªé»å‘½ä»¤"""
    
    FORMAT = '<IHHddfffIB3x'
    SIZE = 36
    
    def __init__(self, timestamp: int, waypoint_id: int, waypoint_count: int,
                 latitude: float, longitude: float, altitude: float,
                 speed: float, hold_time: int, action: int):
        self.timestamp = timestamp
        self.waypoint_id = waypoint_id
        self.waypoint_count = waypoint_count
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude
        self.speed = speed
        self.hold_time = hold_time
        self.action = action
    
    def encode(self) -> bytes:
        return struct.pack(self.FORMAT,
            self.timestamp, self.waypoint_id, self.waypoint_count,
            self.latitude, self.longitude, self.altitude,
            self.speed, self.hold_time, self.action
        )
    
    @classmethod
    def decode(cls, data: bytes) -> 'SetWaypoint':
        values = struct.unpack(cls.FORMAT, data)
        return cls(*values[:9])  # å¿½ç•¥ä¿ç•™å­—ç¯€
    
    def to_dict(self) -> dict:
        return {
            'timestamp': self.timestamp,
            'waypoint_id': self.waypoint_id,
            'waypoint_count': self.waypoint_count,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'altitude': self.altitude,
            'speed': self.speed,
            'hold_time': self.hold_time,
            'action': self.action
        }


# ========== ä½¿ç”¨ç¯„ä¾‹ ==========

def example_send_heartbeat():
    """ç¯„ä¾‹ï¼šç™¼é€å¿ƒè·³åŒ…"""
    import time
    
    # å‰µå»ºå¿ƒè·³æ•¸æ“š
    heartbeat = Heartbeat(
        timestamp=int(time.time() * 1000),
        armed=True,
        mode=2,  # GUIDED
        system_status=1,  # é‹è¡Œä¸­
        online=True
    )
    
    # ç·¨ç¢¼æ•¸æ“šè¼‰è·
    payload = heartbeat.encode()
    
    # ç·¨ç¢¼å®Œæ•´æ•¸æ“šåŒ…
    packet = PacketCodec.encode(
        source=DeviceID.UAV,
        target=DeviceID.GCS,
        data_type=DataType.HEARTBEAT,
        payload=payload
    )
    
    print(f"æ•¸æ“šåŒ…é•·åº¦: {len(packet)} å­—ç¯€")
    print(f"åå…­é€²åˆ¶: {packet.hex(' ').upper()}")
    
    return packet


def example_receive_packet(packet: bytes):
    """ç¯„ä¾‹ï¼šæ¥æ”¶ä¸¦è§£ææ•¸æ“šåŒ…"""
    
    # è§£ç¢¼æ•¸æ“šåŒ…
    result = PacketCodec.decode(packet)
    
    if result is None:
        print("æ•¸æ“šåŒ…æ ¡é©—å¤±æ•—")
        return
    
    source, target, data_type, payload = result
    
    print(f"ä¾†æº: {source.name}")
    print(f"ç›®æ¨™: {target.name}")
    print(f"æ•¸æ“šé¡å‹: {data_type.name} (0x{data_type:04X})")
    
    # æ ¹æ“šæ•¸æ“šé¡å‹è§£æè¼‰è·
    if data_type == DataType.HEARTBEAT:
        heartbeat = Heartbeat.decode(payload)
        print(f"å¿ƒè·³æ•¸æ“š: {heartbeat.to_dict()}")
    
    elif data_type == DataType.ATTITUDE:
        attitude = Attitude.decode(payload)
        print(f"å§¿æ…‹æ•¸æ“š: {attitude.to_dict()}")
    
    elif data_type == DataType.GPS:
        gps = GPS.decode(payload)
        print(f"GPSæ•¸æ“š: {gps.to_dict()}")
    
    elif data_type == DataType.SET_WAYPOINT:
        waypoint = SetWaypoint.decode(payload)
        print(f"èˆªé»è¨­ç½®: {waypoint.to_dict()}")


def example_send_waypoint():
    """ç¯„ä¾‹ï¼šç™¼é€èˆªé»è¨­ç½®å‘½ä»¤"""
    import time
    
    waypoint = SetWaypoint(
        timestamp=int(time.time() * 1000),
        waypoint_id=0,
        waypoint_count=5,
        latitude=23.024087,
        longitude=120.224649,
        altitude=50.0,
        speed=5.0,
        hold_time=0,
        action=0  # ç¶“é
    )
    
    payload = waypoint.encode()
    
    packet = PacketCodec.encode(
        source=DeviceID.GCS,
        target=DeviceID.UAV,
        data_type=DataType.SET_WAYPOINT,
        payload=payload
    )
    
    return packet


if __name__ == '__main__':
    # æ¸¬è©¦ç™¼é€å¿ƒè·³åŒ…
    print("=== æ¸¬è©¦ç™¼é€å¿ƒè·³åŒ… ===")
    packet1 = example_send_heartbeat()
    print()
    
    # æ¸¬è©¦æ¥æ”¶å¿ƒè·³åŒ…
    print("=== æ¸¬è©¦æ¥æ”¶å¿ƒè·³åŒ… ===")
    example_receive_packet(packet1)
    print()
    
    # æ¸¬è©¦ç™¼é€èˆªé»
    print("=== æ¸¬è©¦ç™¼é€èˆªé» ===")
    packet2 = example_send_waypoint()
    print(f"æ•¸æ“šåŒ…é•·åº¦: {len(packet2)} å­—ç¯€")
    print(f"åå…­é€²åˆ¶: {packet2.hex(' ').upper()}")
    print()
    
    # æ¸¬è©¦æ¥æ”¶èˆªé»
    print("=== æ¸¬è©¦æ¥æ”¶èˆªé» ===")
    example_receive_packet(packet2)
```

---

## ğŸ”§ Cèªè¨€å¯¦ç¾ç¯„ä¾‹

### 1. æ•¸æ“šåŒ…çµæ§‹å®šç¾©

```c
// packet_protocol.h
#ifndef PACKET_PROTOCOL_H
#define PACKET_PROTOCOL_H

#include <stdint.h>
#include <stdbool.h>

// å”è­°å¸¸æ•¸
#define HEADER_BYTE 0xFF
#define FOOTER_BYTE 0xFE
#define PROTOCOL_VERSION 0x01

// è¨­å‚™ID
typedef enum {
    DEVICE_GCS = 0x01,      // ä¸­æ§
    DEVICE_UAV = 0x02,      // ç„¡äººæ©Ÿ
    DEVICE_UGV = 0x03,      // ç„¡äººè»Š
    DEVICE_BROADCAST = 0xFF // å»£æ’­
} DeviceID;

// æ•¸æ“šé¡å‹ID
typedef enum {
    // è¼‰å…· â†’ ä¸­æ§
    DATA_HEARTBEAT = 0x0101,
    DATA_ATTITUDE = 0x0102,
    DATA_MOTION = 0x0103,
    DATA_GPS = 0x0104,
    DATA_ALTITUDE = 0x0105,
    DATA_BATTERY = 0x0201,
    DATA_SYSTEM_LOAD = 0x0301,
    
    // ä¸­æ§ â†’ è¼‰å…·
    DATA_GCS_HEARTBEAT = 0x1001,
    DATA_ARM_COMMAND = 0x1002,
    DATA_SET_MODE = 0x1003,
    DATA_SET_HOME = 0x1004,
    DATA_RC_OVERRIDE = 0x1005,
    DATA_SET_WAYPOINT = 0x1101,
    DATA_MISSION_CONTROL = 0x1102,
    
    // å›æ‡‰
    DATA_COMMAND_ACK = 0x1080
} DataType;

// æ•¸æ“šåŒ…é ­çµæ§‹
typedef struct __attribute__((packed)) {
    uint8_t header;         // 0xFF
    uint8_t version;        // å”è­°ç‰ˆæœ¬
    uint8_t source;         // ä¾†æºè¨­å‚™ID
    uint8_t target;         // ç›®æ¨™è¨­å‚™ID
    uint16_t data_type;     // æ•¸æ“šé¡å‹ID
    uint16_t data_length;   // æ•¸æ“šé•·åº¦
} PacketHeader;

// å¿ƒè·³åŒ…
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    uint8_t armed;
    uint8_t mode;
    uint8_t system_status;
    uint8_t online;
} Heartbeat;

// å§¿æ…‹æ•¸æ“š
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    float roll;
    float pitch;
    float yaw;
    float roll_speed;
    float pitch_speed;
    float yaw_speed;
} Attitude;

// GPSæ•¸æ“š
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    double latitude;
    double longitude;
    float altitude;
    uint8_t fix_type;
    uint8_t satellites;
    uint16_t hdop;
} GPS;

// é›»æ± æ•¸æ“š
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    float voltage;
    float current;
    float temperature;
    uint8_t percent;
    uint8_t charging;
    uint16_t remaining_mah;
} Battery;

// RC Override
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    int16_t throttle;
    int16_t roll;
    int16_t pitch;
    int16_t yaw;
    uint8_t enable;
    uint8_t reserved[3];
} RCOverride;

// è¨­å®šèˆªé»
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    uint16_t waypoint_id;
    uint16_t waypoint_count;
    double latitude;
    double longitude;
    float altitude;
    float speed;
    uint32_t hold_time;
    uint8_t action;
    uint8_t reserved[3];
} SetWaypoint;

// å‘½ä»¤ç¢ºèª
typedef struct __attribute__((packed)) {
    uint32_t timestamp;
    uint16_t cmd_id;
    uint8_t result;
    uint8_t error_code;
    uint32_t data;
} CommandAck;

// å‡½æ•¸è²æ˜
uint16_t crc16_ccitt(const uint8_t *data, uint16_t length);
uint16_t packet_encode(uint8_t *buffer, uint16_t buffer_size,
                      DeviceID source, DeviceID target,
                      DataType data_type, const void *payload, 
                      uint16_t payload_size);
bool packet_decode(const uint8_t *buffer, uint16_t buffer_size,
                  DeviceID *source, DeviceID *target,
                  DataType *data_type, void *payload, 
                  uint16_t *payload_size);

#endif // PACKET_PROTOCOL_H
```

### 2. å”è­°å¯¦ç¾

```c
// packet_protocol.c
#include "packet_protocol.h"
#include <string.h>

// CRC16-CCITTè¨ˆç®—
uint16_t crc16_ccitt(const uint8_t *data, uint16_t length) {
    uint16_t crc = 0xFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= (uint16_t)data[i] << 8;
        
        for (uint8_t bit = 0; bit < 8; bit++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc = crc << 1;
            }
        }
    }
    
    return crc;
}

// ç·¨ç¢¼æ•¸æ“šåŒ…
uint16_t packet_encode(uint8_t *buffer, uint16_t buffer_size,
                      DeviceID source, DeviceID target,
                      DataType data_type, const void *payload, 
                      uint16_t payload_size) {
    // æª¢æŸ¥ç·©è¡å€å¤§å°
    uint16_t total_size = 11 + payload_size;
    if (buffer_size < total_size) {
        return 0;  // ç·©è¡å€å¤ªå°
    }
    
    uint16_t pos = 0;
    
    // èµ·å§‹æ¨™è­˜
    buffer[pos++] = HEADER_BYTE;
    
    // å”è­°ç‰ˆæœ¬
    buffer[pos++] = PROTOCOL_VERSION;
    
    // ä¾†æºå’Œç›®æ¨™
    buffer[pos++] = source;
    buffer[pos++] = target;
    
    // æ•¸æ“šé¡å‹ï¼ˆå°ç«¯åºï¼‰
    buffer[pos++] = data_type & 0xFF;
    buffer[pos++] = (data_type >> 8) & 0xFF;
    
    // æ•¸æ“šé•·åº¦ï¼ˆå°ç«¯åºï¼‰
    buffer[pos++] = payload_size & 0xFF;
    buffer[pos++] = (payload_size >> 8) & 0xFF;
    
    // æ•¸æ“šè¼‰è·
    if (payload_size > 0 && payload != NULL) {
        memcpy(&buffer[pos], payload, payload_size);
        pos += payload_size;
    }
    
    // è¨ˆç®—CRCï¼ˆå¾ç‰ˆæœ¬åˆ°æ•¸æ“šè¼‰è·ï¼‰
    uint16_t crc = crc16_ccitt(&buffer[1], pos - 1);
    buffer[pos++] = crc & 0xFF;
    buffer[pos++] = (crc >> 8) & 0xFF;
    
    // çµæŸæ¨™è­˜
    buffer[pos++] = FOOTER_BYTE;
    
    return pos;  // è¿”å›å¯¦éš›åŒ…é•·
}

// è§£ç¢¼æ•¸æ“šåŒ…
bool packet_decode(const uint8_t *buffer, uint16_t buffer_size,
                  DeviceID *source, DeviceID *target,
                  DataType *data_type, void *payload, 
                  uint16_t *payload_size) {
    // æª¢æŸ¥æœ€å°åŒ…é•·
    if (buffer_size < 11) {
        return false;
    }
    
    // æª¢æŸ¥èµ·å§‹å’ŒçµæŸæ¨™è­˜
    if (buffer[0] != HEADER_BYTE || buffer[buffer_size - 1] != FOOTER_BYTE) {
        return false;
    }
    
    // æª¢æŸ¥ç‰ˆæœ¬
    if (buffer[1] != PROTOCOL_VERSION) {
        return false;
    }
    
    // è§£æåŒ…é ­
    *source = (DeviceID)buffer[2];
    *target = (DeviceID)buffer[3];
    *data_type = (DataType)(buffer[4] | (buffer[5] << 8));
    *payload_size = buffer[6] | (buffer[7] << 8);
    
    // æª¢æŸ¥æ•¸æ“šé•·åº¦
    if (buffer_size < 11 + *payload_size) {
        return false;
    }
    
    // é©—è­‰CRC
    uint16_t crc_received = buffer[8 + *payload_size] | 
                           (buffer[9 + *payload_size] << 8);
    uint16_t crc_calculated = crc16_ccitt(&buffer[1], 7 + *payload_size);
    
    if (crc_received != crc_calculated) {
        return false;  // CRCæ ¡é©—å¤±æ•—
    }
    
    // è¤‡è£½è¼‰è·
    if (*payload_size > 0 && payload != NULL) {
        memcpy(payload, &buffer[8], *payload_size);
    }
    
    return true;
}
```

### 3. ä½¿ç”¨ç¯„ä¾‹

```c
// example_usage.c
#include "packet_protocol.h"
#include <stdio.h>
#include <time.h>

// ç™¼é€å¿ƒè·³åŒ…ç¯„ä¾‹
void example_send_heartbeat() {
    uint8_t buffer[256];
    
    // å‰µå»ºå¿ƒè·³æ•¸æ“š
    Heartbeat heartbeat = {
        .timestamp = (uint32_t)(time(NULL) * 1000),
        .armed = 1,
        .mode = 2,  // GUIDED
        .system_status = 1,
        .online = 1
    };
    
    // ç·¨ç¢¼æ•¸æ“šåŒ…
    uint16_t packet_len = packet_encode(
        buffer, sizeof(buffer),
        DEVICE_UAV,          // ä¾†æº: UAV
        DEVICE_GCS,          // ç›®æ¨™: ä¸­æ§
        DATA_HEARTBEAT,      // æ•¸æ“šé¡å‹
        &heartbeat,          // è¼‰è·
        sizeof(heartbeat)    // è¼‰è·å¤§å°
    );
    
    if (packet_len > 0) {
        printf("æ•¸æ“šåŒ…ç·¨ç¢¼æˆåŠŸï¼Œé•·åº¦: %d å­—ç¯€\n", packet_len);
        
        // æ‰“å°åå…­é€²åˆ¶
        printf("åå…­é€²åˆ¶: ");
        for (uint16_t i = 0; i < packet_len; i++) {
            printf("%02X ", buffer[i]);
        }
        printf("\n");
        
        // é€™è£¡å¯ä»¥é€šéä¸²å£æˆ–ç¶²è·¯ç™¼é€ buffer
        // uart_send(buffer, packet_len);
    }
}

// æ¥æ”¶ä¸¦è§£ææ•¸æ“šåŒ…ç¯„ä¾‹
void example_receive_packet(const uint8_t *buffer, uint16_t buffer_size) {
    DeviceID source, target;
    DataType data_type;
    uint8_t payload[256];
    uint16_t payload_size;
    
    // è§£ç¢¼æ•¸æ“šåŒ…
    if (packet_decode(buffer, buffer_size, &source, &target, 
                     &data_type, payload, &payload_size)) {
        printf("æ•¸æ“šåŒ…è§£ç¢¼æˆåŠŸ\n");
        printf("ä¾†æº: 0x%02X\n", source);
        printf("ç›®æ¨™: 0x%02X\n", target);
        printf("æ•¸æ“šé¡å‹: 0x%04X\n", data_type);
        
        // æ ¹æ“šæ•¸æ“šé¡å‹è§£æ
        switch (data_type) {
            case DATA_HEARTBEAT: {
                Heartbeat *hb = (Heartbeat *)payload;
                printf("å¿ƒè·³ - æ­¦è£:%d æ¨¡å¼:%d ç‹€æ…‹:%d\n", 
                       hb->armed, hb->mode, hb->system_status);
                break;
            }
            
            case DATA_ATTITUDE: {
                Attitude *att = (Attitude *)payload;
                printf("å§¿æ…‹ - Roll:%.2f Pitch:%.2f Yaw:%.2f\n",
                       att->roll, att->pitch, att->yaw);
                break;
            }
            
            case DATA_GPS: {
                GPS *gps = (GPS *)payload;
                printf("GPS - ç·¯åº¦:%.6f ç¶“åº¦:%.6f é«˜åº¦:%.2f\n",
                       gps->latitude, gps->longitude, gps->altitude);
                break;
            }
            
            default:
                printf("æœªè™•ç†çš„æ•¸æ“šé¡å‹\n");
                break;
        }
    } else {
        printf("æ•¸æ“šåŒ…è§£ç¢¼å¤±æ•—\n");
    }
}

// ç™¼é€èˆªé»è¨­ç½®ç¯„ä¾‹
void example_send_waypoint() {
    uint8_t buffer[256];
    
    SetWaypoint waypoint = {
        .timestamp = (uint32_t)(time(NULL) * 1000),
        .waypoint_id = 0,
        .waypoint_count = 5,
        .latitude = 23.024087,
        .longitude = 120.224649,
        .altitude = 50.0,
        .speed = 5.0,
        .hold_time = 0,
        .action = 0
    };
    
    uint16_t packet_len = packet_encode(
        buffer, sizeof(buffer),
        DEVICE_GCS,
        DEVICE_UAV,
        DATA_SET_WAYPOINT,
        &waypoint,
        sizeof(waypoint)
    );
    
    if (packet_len > 0) {
        printf("èˆªé»è¨­ç½®åŒ…é•·åº¦: %d å­—ç¯€\n", packet_len);
        // ç™¼é€ buffer
    }
}

int main() {
    printf("=== å”è­°æ¸¬è©¦ ===\n\n");
    
    // æ¸¬è©¦ç™¼é€å¿ƒè·³
    printf("æ¸¬è©¦1: ç™¼é€å¿ƒè·³åŒ…\n");
    example_send_heartbeat();
    printf("\n");
    
    // æ¸¬è©¦ç™¼é€èˆªé»
    printf("æ¸¬è©¦2: ç™¼é€èˆªé»è¨­ç½®\n");
    example_send_waypoint();
    printf("\n");
    
    return 0;
}
```

---

## ğŸ”Œ Arduino/ESP32 ç¯„ä¾‹

```cpp
// Arduino_Protocol.ino
#include <Arduino.h>

// ä½¿ç”¨ä¸Šé¢çš„ packet_protocol.h å’Œ packet_protocol.c

void setup() {
    Serial.begin(115200);
    
    // åˆå§‹åŒ–ç¡¬é«”ä¸²å£ï¼ˆèˆ‡é£›æ§é€šè¨Šï¼‰
    Serial1.begin(9600);
    
    Serial.println("å”è­°æ¸¬è©¦é–‹å§‹");
}

void loop() {
    // æ¯ç§’ç™¼é€ä¸€æ¬¡å¿ƒè·³
    static unsigned long last_heartbeat = 0;
    if (millis() - last_heartbeat > 1000) {
        send_heartbeat();
        last_heartbeat = millis();
    }
    
    // æ¥æ”¶ä¸¦è™•ç†æ•¸æ“šåŒ…
    if (Serial1.available()) {
        receive_packet();
    }
    
    delay(10);
}

void send_heartbeat() {
    uint8_t buffer[256];
    
    Heartbeat hb = {
        .timestamp = millis(),
        .armed = 1,
        .mode = 2,
        .system_status = 1,
        .online = 1
    };
    
    uint16_t len = packet_encode(
        buffer, sizeof(buffer),
        DEVICE_UAV, DEVICE_GCS,
        DATA_HEARTBEAT,
        &hb, sizeof(hb)
    );
    
    if (len > 0) {
        Serial1.write(buffer, len);
        Serial.println("å¿ƒè·³åŒ…å·²ç™¼é€");
    }
}

void receive_packet() {
    static uint8_t buffer[512];
    static uint16_t buffer_pos = 0;
    
    while (Serial1.available()) {
        uint8_t byte = Serial1.read();
        
        // å°‹æ‰¾èµ·å§‹æ¨™è­˜
        if (buffer_pos == 0 && byte != HEADER_BYTE) {
            continue;
        }
        
        buffer[buffer_pos++] = byte;
        
        // æª¢æŸ¥æ˜¯å¦å®Œæˆä¸€å€‹å®Œæ•´çš„åŒ…
        if (buffer_pos >= 11 && byte == FOOTER_BYTE) {
            // è§£ææ•¸æ“šåŒ…
            DeviceID source, target;
            DataType data_type;
            uint8_t payload[256];
            uint16_t payload_size;
            
            if (packet_decode(buffer, buffer_pos, &source, &target,
                            &data_type, payload, &payload_size)) {
                Serial.printf("æ”¶åˆ°æ•¸æ“š: é¡å‹=0x%04X é•·åº¦=%d\n", 
                            data_type, payload_size);
                handle_packet(data_type, payload, payload_size);
            }
            
            buffer_pos = 0;  // é‡ç½®ç·©è¡å€
        }
        
        // é˜²æ­¢ç·©è¡å€æº¢å‡º
        if (buffer_pos >= sizeof(buffer)) {
            buffer_pos = 0;
        }
    }
}

void handle_packet(DataType type, uint8_t *payload, uint16_t size) {
    switch (type) {
        case DATA_RC_OVERRIDE: {
            RCOverride *rc = (RCOverride *)payload;
            Serial.printf("RC: æ²¹é–€=%d æ©«æ»¾=%d\n", rc->throttle, rc->roll);
            // åŸ·è¡ŒRCæ§åˆ¶
            break;
        }
        
        case DATA_SET_WAYPOINT: {
            SetWaypoint *wp = (SetWaypoint *)payload;
            Serial.printf("èˆªé»: ID=%d ç·¯åº¦=%.6f ç¶“åº¦=%.6f\n",
                        wp->waypoint_id, wp->latitude, wp->longitude);
            // è¨­ç½®èˆªé»
            break;
        }
        
        default:
            Serial.println("æœªçŸ¥æ•¸æ“šé¡å‹");
            break;
    }
}
```

---

## ğŸ“Š æ€§èƒ½è€ƒé‡

### æ•¸æ“šåŒ…å¤§å°çµ±è¨ˆ

| æ•¸æ“šé¡å‹ | è¼‰è·å¤§å° | ç¸½åŒ…é•· | é »ç‡ | é »å¯¬ä¼°ç®— |
|---------|---------|--------|------|---------|
| å¿ƒè·³åŒ… | 8 B | 19 B | 1 Hz | 19 B/s |
| å§¿æ…‹æ•¸æ“š | 28 B | 39 B | 20 Hz | 780 B/s |
| GPSæ•¸æ“š | 28 B | 39 B | 5 Hz | 195 B/s |
| é›»æ± ç‹€æ…‹ | 20 B | 31 B | 2 Hz | 62 B/s |
| RC Override | 16 B | 27 B | 20 Hz | 540 B/s |

**ç¸½é »å¯¬ä¼°ç®—**: ç´„ 1.6 KB/sï¼ˆä¸å«å½±åƒï¼‰

### å„ªåŒ–å»ºè­°

1. **æ‰¹æ¬¡ç™¼é€**: å¤šå€‹å°æ•¸æ“šåŒ…åˆä½µç™¼é€
2. **å£“ç¸®**: ä½é »æ•¸æ“šå¯ä½¿ç”¨å£“ç¸®
3. **å„ªå…ˆç´šéšŠåˆ—**: é—œéµæ•¸æ“šå„ªå…ˆç™¼é€
4. **è‡ªé©æ‡‰é »ç‡**: æ ¹æ“šé »å¯¬å‹•æ…‹èª¿æ•´ç™¼é€é »ç‡

---

## ğŸ“ æ¸¬è©¦æ¸…å–®

- [ ] CRC16è¨ˆç®—æ­£ç¢ºæ€§æ¸¬è©¦
- [ ] æ•¸æ“šåŒ…ç·¨ç¢¼/è§£ç¢¼æ¸¬è©¦
- [ ] å¤§å°ç«¯åºæ¸¬è©¦ï¼ˆè·¨å¹³å°ï¼‰
- [ ] éŒ¯èª¤æ•¸æ“šåŒ…è™•ç†æ¸¬è©¦
- [ ] æ€§èƒ½å£“åŠ›æ¸¬è©¦ï¼ˆé«˜é »æ•¸æ“šï¼‰
- [ ] ä¸²å£é€šè¨Šæ¸¬è©¦
- [ ] ç¶²è·¯é€šè¨Šæ¸¬è©¦ï¼ˆUDP/TCPï¼‰
- [ ] æ–·ç·šé‡é€£æ¸¬è©¦
- [ ] æ•¸æ“šå®Œæ•´æ€§æ¸¬è©¦

---

**æœ€å¾Œæ›´æ–°**: 2025-11-21

