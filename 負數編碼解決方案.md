# 負數編碼解決方案分析

**分析日期**: 2025-11-21  
**文檔版本**: v1.1

---

## 📊 當前文檔中負數使用情況

### 需要處理負數的數據類型

| 指令 | 欄位 | 範圍 | 範例 | 字節數需求 |
|------|------|------|------|-----------|
| 指令2 | Roll角度 | -18000 ~ 18000 | -520 | 2字節（有符號） |
| 指令2 | Pitch角度 | -9000 ~ 9000 | -520 | 2字節（有符號） |
| 指令2 | Roll角速度 | 負值可能 | -20 | 2字節（有符號） |
| 指令2 | Pitch角速度 | 負值可能 | -20 | 2字節（有符號） |
| 指令4 | 緯度 | -900000000 ~ 900000000 | -900000000 | 4字節（有符號） |
| 指令4 | 經度 | -1800000000 ~ 1800000000 | -1800000000 | 4字節（有符號） |
| 指令6 | 垂直速度 | 正=上升，負=下降 | -30 | 2字節（有符號） |
| 指令7 | 電池電流 | 正=放電，負=充電 | 負值可能 | 2字節（有符號） |

---

## 🔧 解決方案

### 方案1：二補數（Two's Complement）【推薦】

**原理**：
- 使用標準的二補數表示法
- 這是計算機系統中最常用的負數表示方法
- 與大多數處理器原生支持

**編碼規則**：
- **正數**：直接存儲（如 520 = 0x0208）
- **負數**：使用二補數（如 -520 = 0xFDF8）
- **字節序**：大端序（Big-Endian），高位字節在前

**範例**：

```
角度 -520（度×100）:
- 實際值: -5.20°
- 存儲值: -520 (10進制)
- 二進制（16位有符號）: 1111 1110 0001 1000
- 字節序（大端）: 0xFE, 0x18
- 10進制表示: 65048（無符號解讀）

角度 -30（m/s×100）:
- 實際值: -0.30 m/s
- 存儲值: -30 (10進制)
- 二進制（16位有符號）: 1111 1111 1110 0010
- 字節序（大端）: 0xFF, 0xE2
- 10進制表示: 65506（無符號解讀）

緯度 -900000000（度×10000000）:
- 實際值: -90.0000000°
- 存儲值: -900000000 (10進制)
- 二進制（32位有符號）: 0xCA5E5E00
- 字節序（大端）: 0xCA, 0x5E, 0x5E, 0x00
```

**優點**：
- ✅ 標準方法，廣泛支持
- ✅ 硬體原生支持，運算效率高
- ✅ 與大多數編程語言兼容（C/C++、Python等）
- ✅ 範圍對稱（-32768 ~ 32767 for 16位）

**缺點**：
- ⚠️ 需要明確說明使用二補數
- ⚠️ 在文檔中需要標註數據類型（有符號/無符號）

**實現範例**（Python）：
```python
def encode_signed_int16(value):
    """編碼16位有符號整數（大端序）"""
    if value < 0:
        # 轉換為無符號16位（二補數）
        value = (1 << 16) + value
    return [(value >> 8) & 0xFF, value & 0xFF]

def decode_signed_int16(bytes_data):
    """解碼16位有符號整數（大端序）"""
    value = (bytes_data[0] << 8) | bytes_data[1]
    # 檢查符號位
    if value & 0x8000:
        value = value - (1 << 16)  # 轉換為負數
    return value

# 範例
encoded = encode_signed_int16(-520)  # [0xFE, 0x18]
decoded = decode_signed_int16([0xFE, 0x18])  # -520
```

---

### 方案2：偏移量（Offset/Bias）

**原理**：
- 將負數範圍平移到正數範圍
- 接收方減去偏移量得到實際值

**編碼規則**：
- **偏移量**：取範圍的最小值的絕對值
- **編碼值** = 實際值 + 偏移量
- **解碼值** = 編碼值 - 偏移量

**範例**：

```
角度 -520（度×100，範圍-18000~18000）:
- 偏移量: 18000
- 編碼值: -520 + 18000 = 17480
- 存儲: 17480 (無符號16位)
- 解碼: 17480 - 18000 = -520

角度 -30（m/s×100，假設範圍-1000~1000）:
- 偏移量: 1000
- 編碼值: -30 + 1000 = 970
- 存儲: 970 (無符號16位)
- 解碼: 970 - 1000 = -30

緯度 -900000000（度×10000000，範圍-900000000~900000000）:
- 偏移量: 900000000
- 編碼值: -900000000 + 900000000 = 0
- 存儲: 0 (無符號32位)
- 解碼: 0 - 900000000 = -900000000
```

**優點**：
- ✅ 所有值都是正數，易於理解
- ✅ 校驗和計算簡單（都是正數相加）
- ✅ 不需要處理符號位

**缺點**：
- ⚠️ 需要為每個數據類型定義偏移量
- ⚠️ 增加解碼複雜度
- ⚠️ 範圍不對稱（0 ~ 最大值+偏移量）
- ⚠️ 需要文檔明確說明偏移量

**實現範例**（Python）：
```python
# 定義偏移量
OFFSET_ANGLE = 18000  # 角度偏移量
OFFSET_VELOCITY = 1000  # 速度偏移量
OFFSET_LATITUDE = 900000000  # 緯度偏移量

def encode_with_offset(value, offset):
    """使用偏移量編碼"""
    return value + offset

def decode_with_offset(encoded_value, offset):
    """使用偏移量解碼"""
    return encoded_value - offset

# 範例
encoded = encode_with_offset(-520, OFFSET_ANGLE)  # 17480
decoded = decode_with_offset(17480, OFFSET_ANGLE)  # -520
```

---

### 方案3：符號位 + 絕對值

**原理**：
- 使用一個字節表示符號（0=正，1=負）
- 其餘字節存儲絕對值

**編碼規則**：
- **符號字節**：0 = 正數，1 = 負數
- **數值字節**：存儲絕對值

**範例**：

```
角度 -520（度×100）:
- 符號: 1 (負數)
- 絕對值: 520
- 存儲: [1, 0x02, 0x08]  (符號 + 2字節絕對值)
- 總長度: 3字節

角度 -30（m/s×100）:
- 符號: 1 (負數)
- 絕對值: 30
- 存儲: [1, 0x00, 0x1E]  (符號 + 2字節絕對值)
- 總長度: 3字節
```

**優點**：
- ✅ 直觀易懂
- ✅ 符號和數值分離

**缺點**：
- ⚠️ 增加數據長度（每個負數多1字節）
- ⚠️ 需要修改數據包結構
- ⚠️ 校驗和計算需要特殊處理符號位
- ⚠️ 不適合固定長度數據包設計

---

### 方案4：無符號整數 + 方向標誌

**原理**：
- 數值存儲為無符號整數（絕對值）
- 使用單獨的標誌位表示方向

**編碼規則**：
- **數值**：存儲絕對值（無符號）
- **方向標誌**：0 = 正，1 = 負（可與其他標誌共用字節）

**範例**：

```
角度 -520（度×100）:
- 絕對值: 520
- 方向標誌: 1 (負)
- 存儲: [520的2字節, 方向標誌在狀態字節中]

垂直速度 -30（m/s×100）:
- 絕對值: 30
- 方向標誌: 1 (下降)
- 存儲: [30的2字節, 方向標誌在狀態字節中]
```

**優點**：
- ✅ 數值部分都是正數
- ✅ 可與現有標誌位共用

**缺點**：
- ⚠️ 需要修改數據包結構（添加標誌位）
- ⚠️ 需要為每個負數欄位定義標誌位位置
- ⚠️ 增加解析複雜度

---

## 📋 方案比較表

| 方案 | 數據長度 | 實現複雜度 | 標準化 | 校驗和計算 | 推薦度 |
|------|---------|-----------|--------|-----------|--------|
| 方案1：二補數 | 不變 | 低 | ⭐⭐⭐⭐⭐ | 簡單 | ⭐⭐⭐⭐⭐ |
| 方案2：偏移量 | 不變 | 中 | ⭐⭐⭐ | 簡單 | ⭐⭐⭐⭐ |
| 方案3：符號位 | 增加 | 中 | ⭐⭐ | 複雜 | ⭐⭐ |
| 方案4：方向標誌 | 不變/增加 | 高 | ⭐⭐ | 複雜 | ⭐⭐ |

---

## 💡 推薦方案

### **首選：方案1（二補數）**

**理由**：
1. **標準化**：這是計算機系統的標準負數表示方法
2. **效率高**：硬體原生支持，運算速度快
3. **兼容性好**：與大多數編程語言和處理器兼容
4. **數據長度不變**：不需要修改數據包結構
5. **範圍對稱**：充分利用數據範圍

**需要補充的規範**：
- 明確規定：**所有有符號整數使用二補數（Two's Complement）**
- 明確規定：**字節序使用大端序（Big-Endian）**
- 明確規定：**每個數據類型的字節數和符號性**

### **備選：方案2（偏移量）**

**適用場景**：
- 如果團隊對二補數不熟悉
- 如果希望所有數值都是正數（簡化校驗和計算）

---

## 📝 建議的文檔補充內容

如果採用**方案1（二補數）**，建議在文檔中添加：

```markdown
## 📐 數據編碼規範

### 多字節數據編碼
- **字節序**: 大端序（Big-Endian），高位字節在前
- **負數表示**: 二補數（Two's Complement）
- **數據類型對照表**:

| 數據類型 | 字節數 | 符號性 | 範圍 | 說明 |
|---------|--------|--------|------|------|
| 時間戳（毫秒） | 4 | 無符號 | 0 ~ 4,294,967,295 | uint32 |
| 角度（度×100） | 2 | 有符號 | -32768 ~ 32767 | int16 |
| 角速度（度/秒×100） | 2 | 有符號 | -32768 ~ 32767 | int16 |
| 座標（度×10000000） | 4 | 有符號 | -2,147,483,648 ~ 2,147,483,647 | int32 |
| 速度（m/s×100） | 2 | 無符號/有符號 | 視情況而定 | uint16/int16 |
| 垂直速度（m/s×100） | 2 | 有符號 | -32768 ~ 32767 | int16 |
| 電流（A×100） | 2 | 有符號 | -32768 ~ 32767 | int16 |
| 百分比 | 1 | 無符號 | 0 ~ 255 | uint8 |

### 編碼範例
**角度 -520（度×100）**:
- 實際值: -5.20°
- 存儲值: -520 (10進制)
- 二進制（16位有符號）: 1111 1110 0001 1000
- 字節序（大端）: 0xFE, 0x18
- 10進制表示（無符號解讀）: 65048

**垂直速度 -30（m/s×100）**:
- 實際值: -0.30 m/s
- 存儲值: -30 (10進制)
- 二進制（16位有符號）: 1111 1111 1110 0010
- 字節序（大端）: 0xFF, 0xE2
- 10進制表示（無符號解讀）: 65506

**緯度 -900000000（度×10000000）**:
- 實際值: -90.0000000°
- 存儲值: -900000000 (10進制)
- 二進制（32位有符號）: 1100 1010 0101 1110 0101 1110 0000 0000
- 字節序（大端）: 0xCA, 0x5E, 0x5E, 0x00
```

---

## 🔍 校驗和計算注意事項

### 使用二補數時的校驗和計算

**重要**：校驗和計算時，直接使用**原始字節值**相加，不需要考慮符號。

**範例**：
```
數據包: 0xFF, 2, 1, 2, 12345678, 0xFE, 0x18, 310, 18000, 10, 0xFF, 0xE2, 50

校驗和計算:
2 + 1 + 2 + 12345678 + 0xFE + 0x18 + 310 + 18000 + 10 + 0xFF + 0xE2 + 50
= 2 + 1 + 2 + 12345678 + 254 + 24 + 310 + 18000 + 10 + 255 + 226 + 50
= 12363810
取低8位: 12363810 & 0xFF = 162
```

**說明**：
- 校驗和計算時，負數的二補數表示（如 0xFE, 0x18）直接作為字節值參與計算
- 不需要先解碼為負數再計算
- 這樣可以保持校驗和算法的簡單性

---

## ✅ 總結

**推薦方案**：**方案1（二補數）**

**優點總結**：
- ✅ 標準化、高效、兼容性好
- ✅ 不需要修改數據包結構
- ✅ 校驗和計算簡單（直接使用字節值）
- ✅ 範圍對稱，充分利用數據範圍

**實施建議**：
1. 在文檔中明確規定使用二補數
2. 明確規定字節序（大端序）
3. 為每個數據類型標註字節數和符號性
4. 提供編碼/解碼範例代碼

---

**文檔維護**: 專案團隊  
**最後更新**: 2025-11-21

