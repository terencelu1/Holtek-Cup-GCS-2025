# 中控系統數據格式規範

**版本**: v1.6  
**最後更新**: 2025-11-21

---
指令 1: 4 個欄位
指令 2: 7 個欄位
指令 3: 5 個欄位
指令 4: 7 個欄位
指令 5: 2 個欄位
指令 6: 2 個欄位
指令 7: 5 個欄位
指令 8: 6 個欄位
指令 9: 5 個欄位
指令 10: 5 個欄位
指令 11: 2 個欄位
指令 12: 2 個欄位
指令 13: 4 個欄位
指令 14: 8 個欄位
指令 15: 1 個欄位
指令 16: 4 個欄位
指令 17: 5 個欄位
指令 18: 4 個欄位

## 📋 設計原則

- **起始標識**: 0xFF (16進制)
- **數據表示**: 10進制
- **校驗**: 8位校驗和（簡單累加，算力要求低）
- **結束標識**: 無需結束標識（校驗和位於包尾）
- **簡化設計**: 重複發送前一個指令包即可，不強制要求心跳包

---

## 🆔 裝置ID定義

| 裝置ID | 名稱 | 說明 |
|-------|------|------|
| 1 | 中控系統 | 地面控制站（GCS） |
| 2 | 無人機 (UAV) | 空中載具 |
| 3 | 無人車 (UGV) | 地面載具 |
| 255 | 廣播 | 所有載具 |

**說明**:
- 裝置ID使用1-254範圍，255保留為廣播地址
- 未來可擴展多台載具（例如：UAV1=2, UAV2=4, UGV1=3, UGV2=5）

---

## 📦 數據包通用格式

```
+------+----------+----------+-------------+----------+----------+
| 起始 | 來源ID   | 目標ID   | 指令類型    | 數據內容  | 校驗和   |
+------+----------+----------+-------------+----------+----------+
| 0xFF | 1 字節   | 1 字節   |  1 字節     |  N 字節   | 1 字節   |
+------+----------+----------+-------------+----------+----------+
```

### 欄位說明

| 欄位 | 格式 | 範圍 | 說明 |
|------|------|------|------|
| 起始標識 | 16進制 | 0xFF | 固定值 |
| 來源ID | 10進制 | 1-255 | 發送方裝置ID |
| 目標ID | 10進制 | 1-255 | 接收方裝置ID |
| 指令類型 | 10進制 | 1-255 | 數據/命令類型 |
| 數據內容 | 10進制 | 不定長 | 實際數據載荷 |
| 校驗和 | 10進制 | 0-255 | 8位校驗和（見下方算法）|

**範例**: 
```
0xFF, 2, 1, 1, 數據..., 校驗和
解讀: 起始0xFF, 來源=UAV(2), 目標=中控(1), 指令類型=1, 數據..., 校驗和
```

---

## 📐 數據編碼規範

### 多字節數據編碼規則

**字節序**: 大端序（Big-Endian），高位字節在前  
**負數表示**: 偏移量（Offset/Bias），所有值統一為正數，使用10進制表示  
**數據表示**: 10進制（在傳輸時轉換為字節序列）

### 偏移量定義

為避免負數表示混亂（二補數會導致十進制/十六進制混用），本協議使用**偏移量法**處理負數：

| 數據類型 | 原始範圍 | 偏移量 | 編碼後範圍 | 字節數 | 說明 |
|---------|---------|--------|-----------|--------|------|
| Roll角度（度×100） | -18000 ~ 18000 | 18000 | 0 ~ 36000 | 2 | 無符號16位 |
| Pitch角度（度×100） | -9000 ~ 9000 | 9000 | 0 ~ 18000 | 2 | 無符號16位 |
| 角速度（度/秒×100） | -1000 ~ 1000 | 1000 | 0 ~ 2000 | 2 | 無符號16位 |
| 緯度（度×10000000） | -900000000 ~ 900000000 | 900000000 | 0 ~ 1800000000 | 4 | 無符號32位 |
| 經度（度×10000000） | -1800000000 ~ 1800000000 | 1800000000 | 0 ~ 3600000000 | 4 | 無符號32位（注意：最大值超出uint32範圍，實際使用時需調整）|
| 垂直速度（m/s×100） | -1000 ~ 1000 | 1000 | 0 ~ 2000 | 2 | 無符號16位 |
| 電流（A×100） | -1000 ~ 1000 | 1000 | 0 ~ 2000 | 2 | 無符號16位 |

### 經度編碼特殊說明

**為什麼經度使用二補數？**

經度範圍：-1800000000 ~ 1800000000（度×10000000）

如果使用偏移量法：
- 偏移量：1800000000
- 編碼後範圍：0 ~ 3600000000
- **問題**：超出32位無符號整數最大值（4,294,967,295）

因此，**經度是唯一使用有符號32位整數（二補數）的數據類型**。

**注意事項**：
- 經度在範例中可能顯示為負數（如 -1206468540）
- 實際傳輸時使用二補數編碼（有符號32位）
- 校驗和計算時，使用字節值相加（與其他數據相同，見下方說明）
- 其他所有負數數據均使用偏移量法，統一為正數

### 數據類型對照表

| 數據類型 | 字節數 | 編碼方式 | 範圍 | C語言類型 | 說明 |
|---------|--------|---------|------|----------|------|
| 時間戳（毫秒） | 4 | 直接存儲 | 0 ~ 4,294,967,295 | uint32_t | 開機時間戳 |
| 絕對時間戳（秒） | 4 | 直接存儲 | 0 ~ 4,294,967,295 | uint32_t | Unix時間戳 |
| Roll角度（度×100） | 2 | 偏移量+18000 | 0 ~ 36000 | uint16_t | 編碼值=實際值+18000 |
| Pitch角度（度×100） | 2 | 偏移量+9000 | 0 ~ 18000 | uint16_t | 編碼值=實際值+9000 |
| 角速度（度/秒×100） | 2 | 偏移量+1000 | 0 ~ 2000 | uint16_t | 編碼值=實際值+1000 |
| 緯度（度×10000000） | 4 | 偏移量+900000000 | 0 ~ 1800000000 | uint32_t | 編碼值=實際值+900000000 |
| 經度（度×10000000） | 4 | 有符號32位 | -1800000000 ~ 1800000000 | int32_t | 使用二補數（範圍太大，無法用偏移量）|
| 速度（m/s×100） | 2 | 直接存儲 | 0 ~ 65,535 | uint16_t | 地面速度、空速 |
| 垂直速度（m/s×100） | 2 | 偏移量+1000 | 0 ~ 2000 | uint16_t | 編碼值=實際值+1000 |
| 電流（A×100） | 2 | 偏移量+1000 | 0 ~ 2000 | uint16_t | 編碼值=實際值+1000 |
| 高度（公尺×100） | 2 | 直接存儲 | 0 ~ 65,535 | uint16_t | 海拔高度、Lidar高度 |
| 百分比 | 1 | 直接存儲 | 0 ~ 255 | uint8_t | 容量、油門等 |
| 單字節標誌 | 1 | 直接存儲 | 0 ~ 255 | uint8_t | 狀態標誌、模式代碼等 |

### 偏移量編碼說明

**原理**：
- 將負數範圍平移到正數範圍
- 編碼值 = 實際值 + 偏移量
- 解碼值 = 編碼值 - 偏移量
- **所有值都是正數，統一使用10進制表示**

**編碼範例**：

**Roll角度 -520（度×100）**:
- 實際值: -5.20°
- 偏移量: 18000
- 編碼值: -520 + 18000 = 17480
- 存儲: 17480 (10進制，無符號16位)
- 解碼: 17480 - 18000 = -520

**Pitch角度 -310（度×100）**:
- 實際值: -3.10°
- 偏移量: 9000
- 編碼值: -310 + 9000 = 8690
- 存儲: 8690 (10進制，無符號16位)
- 解碼: 8690 - 9000 = -310

**垂直速度 -30（m/s×100）**:
- 實際值: -0.30 m/s
- 偏移量: 1000
- 編碼值: -30 + 1000 = 970
- 存儲: 970 (10進制，無符號16位)
- 解碼: 970 - 1000 = -30

**緯度 -900000000（度×10000000）**:
- 實際值: -90.0000000°
- 偏移量: 900000000
- 編碼值: -900000000 + 900000000 = 0
- 存儲: 0 (10進制，無符號32位)
- 解碼: 0 - 900000000 = -900000000

**經度**（特殊處理，使用有符號32位，二補數）:
- 實際值: -1800000000（度×10000000）
- 存儲: -1800000000 (使用二補數，有符號32位)
- 二進制（32位有符號）: `1001 0101 1010 0001 1110 0010 0000 0000`
- 字節序（大端）: `0x95, 0xA1, 0xE2, 0x00`
- 10進制表示（無符號解讀）: 2,510,192,640
- **注意**：經度是唯一使用二補數編碼的數據類型，範圍太大無法使用偏移量

### 編碼/解碼範例代碼

**Python範例**:
```python
import struct

# 偏移量定義
OFFSET_ROLL_ANGLE = 18000
OFFSET_PITCH_ANGLE = 9000
OFFSET_ANGULAR_VELOCITY = 1000
OFFSET_LATITUDE = 900000000
OFFSET_VERTICAL_VELOCITY = 1000
OFFSET_CURRENT = 1000

def encode_uint16(value):
    """編碼16位無符號整數（大端序）"""
    return list(struct.pack('>H', value))  # '>H' = big-endian unsigned short

def decode_uint16(bytes_data):
    """解碼16位無符號整數（大端序）"""
    return struct.unpack('>H', bytes(bytes_data))[0]

def encode_uint32(value):
    """編碼32位無符號整數（大端序）"""
    return list(struct.pack('>I', value))  # '>I' = big-endian unsigned int

def decode_uint32(bytes_data):
    """解碼32位無符號整數（大端序）"""
    return struct.unpack('>I', bytes(bytes_data))[0]

def encode_int32(value):
    """編碼32位有符號整數（大端序，僅用於經度）"""
    return list(struct.pack('>i', value))  # '>i' = big-endian signed int

def decode_int32(bytes_data):
    """解碼32位有符號整數（大端序，僅用於經度）"""
    return struct.unpack('>i', bytes(bytes_data))[0]

# 範例：Roll角度編碼/解碼
roll_angle = -520  # 實際值
encoded_value = roll_angle + OFFSET_ROLL_ANGLE  # 17480
encoded_bytes = encode_uint16(encoded_value)  # [0x44, 0x38]
decoded_value = decode_uint16(encoded_bytes)  # 17480
actual_value = decoded_value - OFFSET_ROLL_ANGLE  # -520
```

**C/C++範例**:
```c
#include <stdint.h>
#include <arpa/inet.h>  // 或 <winsock2.h> for Windows

// 偏移量定義
#define OFFSET_ROLL_ANGLE 18000
#define OFFSET_PITCH_ANGLE 9000
#define OFFSET_ANGULAR_VELOCITY 1000
#define OFFSET_LATITUDE 900000000
#define OFFSET_VERTICAL_VELOCITY 1000
#define OFFSET_CURRENT 1000

// 編碼16位無符號整數（大端序）
void encode_uint16(uint16_t value, uint8_t* bytes) {
    uint16_t network_value = htons(value);
    memcpy(bytes, &network_value, 2);
}

// 解碼16位無符號整數（大端序）
uint16_t decode_uint16(uint8_t* bytes) {
    uint16_t network_value;
    memcpy(&network_value, bytes, 2);
    return ntohs(network_value);
}

// 編碼32位無符號整數（大端序）
void encode_uint32(uint32_t value, uint8_t* bytes) {
    uint32_t network_value = htonl(value);
    memcpy(bytes, &network_value, 4);
}

// 解碼32位無符號整數（大端序）
uint32_t decode_uint32(uint8_t* bytes) {
    uint32_t network_value;
    memcpy(&network_value, bytes, 4);
    return ntohl(network_value);
}

// 範例：Roll角度編碼/解碼
int16_t roll_angle = -520;  // 實際值
uint16_t encoded_value = roll_angle + OFFSET_ROLL_ANGLE;  // 17480
uint8_t bytes[2];
encode_uint16(encoded_value, bytes);
uint16_t decoded_value = decode_uint16(bytes);  // 17480
int16_t actual_value = decoded_value - OFFSET_ROLL_ANGLE;  // -520
```

### 字節拆分規則

**多字節數據拆分**：
- 所有多字節數據使用大端序（Big-Endian）
- 高位字節在前，低位字節在後
- **校驗和計算時，必須將多字節數據拆分為字節後，逐字節相加**

**拆分範例**：

**16位無符號整數（2字節）**:
- 數值: 17480 (10進制)
- 16進制: 0x4448
- 字節序列（大端）: [0x44, 0x48]
- 10進制表示: [68, 72]

**32位無符號整數（4字節）**:
- 數值: 12345678 (10進制)
- 16進制: 0x00BC614E
- 字節序列（大端）: [0x00, 0xBC, 0x61, 0x4E]
- 10進制表示: [0, 188, 97, 78]

**32位有符號整數（4字節，僅用於經度）**:
- 數值: 1206468540 (10進制，正數)
- 16進制: 0x47E5F1BC
- 字節序列（大端）: [0x47, 0xE5, 0xF1, 0xBC]
- 10進制表示: [71, 229, 241, 188]

- 數值: -1206468540 (10進制，負數，使用二補數)
- 16進制: 0xB81A0E44
- 字節序列（大端）: [0xB8, 0x1A, 0x0E, 0x44]
- 10進制表示: [184, 26, 14, 68]

### 校驗和計算注意事項

**重要**：校驗和計算時，**必須將多字節數據拆分為字節後，逐字節相加**，不能直接將數值相加。

**錯誤示例**（❌ 錯誤）：
```
數據包: 0xFF, 2, 1, 1, 12345678, 1, 2, 1
錯誤計算: 2 + 1 + 1 + 12345678 + 1 + 2 + 1 = 12345686
```

**正確示例**（✅ 正確）：
```
數據包: 0xFF, 2, 1, 1, 12345678, 1, 2, 1

步驟1: 將多字節數據拆分為字節（大端序）
       12345678 (10進制) = 0x00BC614E (16進制)
       拆分為: [0x00, 0xBC, 0x61, 0x4E] = [0, 188, 97, 78]

步驟2: 提取需要計算的部分（跳過起始0xFF）
       2, 1, 1, [0, 188, 97, 78], 1, 2, 1

步驟3: 按字節累加所有值
       2 + 1 + 1 + 0 + 188 + 97 + 78 + 1 + 2 + 1 = 371

步驟4: 取低8位（與0xFF做AND運算）
       371 & 0xFF = 115

步驟5: 附加校驗和到數據包末尾
完整包: 0xFF, 2, 1, 1, [0x00, 0xBC, 0x61, 0x4E], 1, 2, 1, 115
         ↑起始  ↑來源 ↑目標 ↑指令 ↑時間戳(4字節)    ↑數據 ↑校驗和
```

**另一個範例（指令2：姿態數據）**：
```
數據包: 0xFF, 2, 1, 2, 12345678, 17480, 9310, 18000, 1010, 980, 1050

字節拆分:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] = [0, 188, 97, 78]
- Roll角度 17480: [0x44, 0x48] = [68, 72]
- Pitch角度 9310: [0x24, 0x6E] = [36, 110]
- Yaw角度 18000: [0x46, 0x50] = [70, 80]
- Roll角速度 1010: [0x03, 0xF2] = [3, 242]
- Pitch角速度 980: [0x03, 0xD4] = [3, 212]
- Yaw角速度 1050: [0x04, 0x1A] = [4, 26]

校驗和計算（按字節）:
2 + 1 + 2 + 0 + 188 + 97 + 78 + 68 + 72 + 36 + 110 + 70 + 80 + 3 + 242 + 3 + 212 + 4 + 26
= 1295
取低8位: 1295 & 0xFF = 15

完整包: 0xFF, 2, 1, 2, [0x00, 0xBC, 0x61, 0x4E], [0x44, 0x48], [0x24, 0x6E], [0x46, 0x50], [0x03, 0xF2], [0x03, 0xD4], [0x04, 0x1A], 15
```

---

## 🔐 校驗算法

### 8位校驗和（Checksum）

**算法**: 簡單累加和，取低8位

**計算範圍**: 從來源ID到數據內容的最後一個字節（不包含起始標識0xFF）

**計算步驟**:
1. **將所有多字節數據拆分為字節**（大端序）
2. **按字節順序**，將來源ID、目標ID、指令類型、所有數據字節相加
3. 取結果的低8位（即結果 & 0xFF）
4. 得到校驗和值（0-255）

**重要**：必須按字節相加，不能直接將數值相加。例如，12345678 必須拆分為 [0x00, 0xBC, 0x61, 0x4E] 後再相加。

**偽代碼**:
```python
def calculate_checksum(packet):
    """
    計算8位校驗和
    packet: 完整數據包（包含0xFF起始標識）
    """
    checksum = 0
    # 從來源ID開始計算（跳過起始標識0xFF）
    for i in range(1, len(packet) - 1):  # 排除起始和校驗和本身
        checksum += packet[i]
    return checksum & 0xFF  # 取低8位
```

**範例計算**（指令1：系統狀態）:
```
原始數據: 0xFF, 2, 1, 1, 12345678, 1, 2, 1

步驟1: 將多字節數據拆分為字節（大端序）
       時間戳 12345678 (10進制) = 0x00BC614E (16進制)
       拆分為: [0x00, 0xBC, 0x61, 0x4E] = [0, 188, 97, 78]

步驟2: 提取需要計算的部分（跳過起始0xFF）
       2, 1, 1, [0, 188, 97, 78], 1, 2, 1

步驟3: 按字節累加所有值
       2 + 1 + 1 + 0 + 188 + 97 + 78 + 1 + 2 + 1 = 371

步驟4: 取低8位（與0xFF做AND運算）
       371 & 0xFF = 115

步驟5: 附加校驗和到數據包末尾
完整包: 0xFF, 2, 1, 1, [0x00, 0xBC, 0x61, 0x4E], 1, 2, 1, 115
         ↑起始  ↑來源 ↑目標 ↑指令 ↑時間戳(4字節)    ↑數據 ↑校驗和

字節序列（實際傳輸）:
0xFF, 2, 1, 1, 0x00, 0xBC, 0x61, 0x4E, 1, 2, 1, 115
```

**另一個範例（指令11：武裝命令）**:
```
原始數據: 0xFF, 1, 2, 11, 1, 0

步驟1: 所有數據都是單字節，無需拆分
步驟2: 按字節累加（跳過起始0xFF）
       1 + 2 + 11 + 1 + 0 = 15
步驟3: 取低8位
       15 & 0xFF = 15

完整包: 0xFF, 1, 2, 11, 1, 0, 15
字節序列: 0xFF, 1, 2, 11, 1, 0, 15
```

**驗證步驟**:
1. 接收完整數據包
2. 提取校驗和（最後一個字節）
3. 重新計算校驗和（從來源ID到倒數第二個字節）
4. 比對計算結果與接收到的校驗和
5. 一致則通過，不一致則丟棄

**優點**:
- ✅ 算力要求極低（只需簡單加法）
- ✅ 實現簡單（幾行代碼）
- ✅ 可檢測大部分傳輸錯誤
- ✅ 單字節校驗，開銷小

**限制**:
- ⚠️ 無法檢測字節順序交換
- ⚠️ 無法檢測多個錯誤互相抵消的情況
- ⚠️ 適合穩定通訊環境

---

## ⏰ 時間戳類型說明

### 📍 絕對時間戳 (Unix Time)
**格式**: 10進制，單位：秒  
**定義**: 自1970年1月1日00:00:00 UTC以來的秒數  
**範圍**: 0 ~ 4,294,967,295 (到2106年)

**使用場景**:
- 充電記錄（需要記錄實際日期時間）
- 數據歸檔（需要按日期檢索）

---

### 🔄 開機時間戳 (Boot Time)
**格式**: 10進制，單位：毫秒  
**定義**: 載具開機後經過的毫秒數  
**範圍**: 0 ~ 4,294,967,295 毫秒 (約49.7天)

**使用場景**:
- 姿態數據（用於姿態指示儀同步）
- 運動數據（用於速度、油門記錄）
- 性能圖表（用於時間軸對齊）
- 高頻數據（減少數據量，提高效率）

---

## 📤 載具 → 中控（數據上傳）

### 指令類型 1-50: 基礎狀態

#### 指令 1: 系統狀態
**頻率**: 1 Hz（每秒發送一次，可替代心跳包功能）  
**數據長度**: 4 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 武裝狀態 | 10進制 | - | 0=解除武裝, 1=已武裝 |
| 3 | 運作模式 | 10進制 | - | 見模式代碼表 |
| 4 | 系統狀態 | 10進制 | - | 0=待機, 1=運行中, 2=執行任務中, 3=錯誤 |

**運作模式代碼**:
- 0 = 手動模式 (Manual)
- 1 = 自穩模式 (Stabilize，UAV專用)
- 2 = 導航模式 (Guided)
- 3 = 自動模式 (Auto)
- 4 = 盤旋模式 (Loiter)
- 5 = 返航模式 (RTL)
- 6 = 降落模式 (Land，UAV專用)
- 7 = 保持模式 (Hold)

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 1, 12345678, 1, 2, 1

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 1, [0x00, 0xBC, 0x61, 0x4E], 1, 2, 1

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 武裝狀態 1: 1 (1字節)
- 運作模式 2: 2 (1字節)
- 系統狀態 1: 1 (1字節)

解讀: UAV→中控, 指令1, 開機12345678毫秒, 已武裝, 導航模式, 運行中

校驗和計算（按字節）:
2 + 1 + 1 + 0 + 188 + 97 + 78 + 1 + 2 + 1 = 371
校驗和 = 371 & 0xFF = 115

完整包: 0xFF, 2, 1, 1, [0x00, 0xBC, 0x61, 0x4E], 1, 2, 1, 115
```

---

#### 指令 2: 姿態數據
**頻率**: 20 Hz  
**時間戳**: 開機時間戳（用於姿態指示儀、性能圖表）  
**數據長度**: 7 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | Roll角度 | 10進制 | 度×100 | 橫滾角（-18000 ~ 18000，代表-180.00° ~ 180.00°，編碼值=實際值+18000，範圍0~36000）|
| 3 | Pitch角度 | 10進制 | 度×100 | 俯仰角（-9000 ~ 9000，代表-90.00° ~ 90.00°，編碼值=實際值+9000，範圍0~18000）|
| 4 | Yaw角度 | 10進制 | 度×100 | 偏航角（0 ~ 36000，代表0.00° ~ 360.00°，無符號16位）|
| 5 | Roll角速度 | 10進制 | 度/秒×100 | 橫滾角速度（編碼值=實際值+1000，範圍0~2000）|
| 6 | Pitch角速度 | 10進制 | 度/秒×100 | 俯仰角速度（編碼值=實際值+1000，範圍0~2000）|
| 7 | Yaw角速度 | 10進制 | 度/秒×100 | 偏航角速度（編碼值=實際值+1000，範圍0~2000）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 2, 12345678, 17480, 9310, 18000, 1010, 980, 1050, 15

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 2, [0x00, 0xBC, 0x61, 0x4E], [0x44, 0x48], [0x24, 0x6E], [0x46, 0x50], [0x03, 0xF2], [0x03, 0xD4], [0x04, 0x1A], 15

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- Roll角度 17480: [0x44, 0x48] (2字節，無符號16位，實際值=17480-18000=-520)
- Pitch角度 9310: [0x24, 0x6E] (2字節，無符號16位，實際值=9310-9000=310)
- Yaw角度 18000: [0x46, 0x50] (2字節，無符號16位)
- Roll角速度 1010: [0x03, 0xF2] (2字節，無符號16位，實際值=1010-1000=10)
- Pitch角速度 980: [0x03, 0xD4] (2字節，無符號16位，實際值=980-1000=-20)
- Yaw角速度 1050: [0x04, 0x1A] (2字節，無符號16位，實際值=1050-1000=50)

解讀: UAV→中控, 指令2, 時間戳, Roll=-5.20°, Pitch=3.10°, Yaw=180.00°, Roll角速度=0.10°/s, Pitch角速度=-0.20°/s, Yaw角速度=0.50°/s

校驗和計算（按字節）:
2 + 1 + 2 + 0 + 188 + 97 + 78 + 68 + 72 + 36 + 110 + 70 + 80 + 3 + 242 + 3 + 212 + 4 + 26 = 1295
校驗和 = 1295 & 0xFF = 15
```

---

#### 指令 3: 運動數據
**頻率**: 10 Hz  
**時間戳**: 開機時間戳（用於性能圖表、載具朝向）  
**數據長度**: 5 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 地面速度 | 10進制 | m/s×100 | 地面速度（0 ~ 65535，代表0.00 ~ 655.35 m/s）|
| 3 | 空速 | 10進制 | m/s×100 | 空速（UAV專用，UGV填0）|
| 4 | 航向 | 10進制 | 度×100 | 航向（0 ~ 36000，代表0.00° ~ 360.00°）|
| 5 | 油門百分比 | 10進制 | % | 油門（0 ~ 100）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 3, 12345678, 320, 350, 18000, 55

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 3, [0x00, 0xBC, 0x61, 0x4E], [0x01, 0x40], [0x01, 0x5E], [0x46, 0x50], 55

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 地面速度 320: [0x01, 0x40] (2字節，無符號16位)
- 空速 350: [0x01, 0x5E] (2字節，無符號16位)
- 航向 18000: [0x46, 0x50] (2字節，無符號16位)
- 油門百分比 55: 55 (1字節)

解讀: UAV→中控, 指令3, 時間戳, 地速=3.20m/s, 空速=3.50m/s, 航向=180.00°, 油門=55%
```

---

#### 指令 4: GPS定位數據
**頻率**: 5 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 7 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 緯度 | 10進制 | 度×10000000 | 緯度（-900000000 ~ 900000000，編碼值=實際值+900000000，範圍0~1800000000）|
| 3 | 經度 | 10進制 | 度×10000000 | 經度（-1800000000 ~ 1800000000，有符號32位，使用二補數，範圍太大無法用偏移量）|
| 4 | 高度 | 10進制 | 公尺×100 | 海拔高度 |
| 5 | 定位類型 | 10進制 | - | 0=無, 1=無GPS, 2=2D, 3=3D, 4=差分GPS, 5=RTK浮點, 6=RTK固定 |
| 6 | 衛星數量 | 10進制 | 顆 | 可見衛星數 |
| 7 | HDOP | 10進制 | ×100 | 水平精度因子（50=0.50）|

**範例數據包**（正數緯度、正數經度）:
```
數值表示: 0xFF, 2, 1, 4, 12345678, 1140240870, 1206468540, 15020, 3, 14, 70

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 4, [0x00, 0xBC, 0x61, 0x4E], [0x43, 0xF0, 0x5E, 0x26], [0x47, 0xE5, 0xF1, 0xBC], [0x3A, 0xAC], 3, 14, 70

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 1206468540: [0x47, 0xE5, 0xF1, 0xBC] (4字節，有符號32位，二補數編碼，正數)
  實際經度 = 1206468540 ÷ 10000000 = 120.646854°（東經）
- 高度 15020: [0x3A, 0xAC] (2字節，無符號16位)
- 定位類型 3: 3 (1字節)
- 衛星數量 14: 14 (1字節)
- HDOP 70: 70 (1字節)

解讀: UAV→中控, 指令4, 緯度=24.024087°N, 經度=120.646854°E, 高度=150.20m, 3D定位, 14顆衛星, HDOP=0.70
```

**範例數據包**（負數經度，展示二補數編碼）:
```
數值表示: 0xFF, 2, 1, 4, 12345678, 1140240870, -1206468540, 15020, 3, 14, 70

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 4, [0x00, 0xBC, 0x61, 0x4E], [0x43, 0xF0, 0x5E, 0x26], [0xB8, 0x1A, 0x0E, 0x44], [0x3A, 0xAC], 3, 14, 70

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 -1206468540: [0xB8, 0x1A, 0x0E, 0x44] (4字節，有符號32位，二補數編碼，負數)
  實際經度 = -1206468540 ÷ 10000000 = -120.646854°（西經120.646854°）
- 高度 15020: [0x3A, 0xAC] (2字節，無符號16位)
- 定位類型 3: 3 (1字節)
- 衛星數量 14: 14 (1字節)
- HDOP 70: 70 (1字節)

解讀: UAV→中控, 指令4, 緯度=24.024087°N, 經度=120.646854°W, 高度=150.20m, 3D定位, 14顆衛星, HDOP=0.70

**注意**：
- 緯度使用偏移量編碼：編碼值 = 實際值 + 900000000
- 經度使用二補數編碼（有符號32位），是唯一使用二補數的數據類型
- 其他負數數據均使用偏移量法，統一為正數
```

---

#### 指令 5: Lidar高度數據（UAV專用）
**頻率**: 10 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 2 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | Lidar高度 | 10進制 | 公尺×100 | 距地高度（Lidar測量）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 5, 12345678, 1520

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 5, [0x00, 0xBC, 0x61, 0x4E], [0x05, 0xF0]

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- Lidar高度 1520: [0x05, 0xF0] (2字節，無符號16位)

解讀: UAV→中控, 指令5, Lidar高度=15.20m
```

---

#### 指令 6: 爬升率（UAV專用）
**頻率**: 10 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 2 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 垂直速度 | 10進制 | m/s×100 | 爬升率（正=上升，負=下降，編碼值=實際值+1000，範圍0~2000）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 6, 12345678, 970

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 6, [0x00, 0xBC, 0x61, 0x4E], [0x03, 0xCA]

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 垂直速度 970: [0x03, 0xCA] (2字節，無符號16位，實際值=970-1000=-30)

解讀: UAV→中控, 指令6, 垂直速度=-0.30m/s（下降中）
```

---

### 指令類型 7-8: 電源狀態

#### 指令 7: 電池狀態
**頻率**: 2 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 5 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 電壓 | 10進制 | 伏特×100 | 電池電壓（1540 = 15.40V，無符號）|
| 3 | 電流 | 10進制 | 安培×100 | 電池電流（編碼值=實際值+1000，範圍0~2000，正=放電，負=充電，範例：1250=2.50A放電，250=-7.50A充電）|
| 4 | 容量百分比 | 10進制 | % | 剩餘電量（0 ~ 100，無符號）|
| 5 | 溫度 | 10進制 | 攝氏度×10 | 電池溫度（350 = 35.0°C，無符號）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 7, 12345678, 1540, 1250, 78, 350

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 7, [0x00, 0xBC, 0x61, 0x4E], [0x06, 0x04], [0x04, 0xE2], 78, [0x01, 0x5E]

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 電壓 1540: [0x06, 0x04] (2字節，無符號16位)
- 電流 1250: [0x04, 0xE2] (2字節，無符號16位，偏移量編碼，實際值=1250-1000=250，表示放電2.50A)
- 容量百分比 78: 78 (1字節)
- 溫度 350: [0x01, 0x5E] (2字節，無符號16位)

解讀: UAV→中控, 指令7, 電壓=15.40V, 電流=2.50A（放電）, 容量=78%, 溫度=35.0°C
```

---

#### 指令 8: 充電狀態
**頻率**: 1 Hz（充電時）  
**時間戳**: 絕對時間戳（用於記錄充電歷史，需要查詢具體時間）  
**數據長度**: 6 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 絕對時間戳 | 10進制 | 秒 | Unix時間戳 |
| 2 | 充電電壓 | 10進制 | 伏特×100 | 充電器輸出電壓 |
| 3 | 充電電流 | 10進制 | 安培×100 | 充電電流 |
| 4 | 充電狀態 | 10進制 | - | 0=未充電, 1=充電中, 2=充滿 |
| 5 | 已充入容量 | 10進制 | mAh | 本次充入的電量 |
| 6 | 預計充滿時間 | 10進制 | 分鐘 | 預計還需多久充滿（0=已充滿）|

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 8, 1732176000, 1680, 180, 1, 1250, 45

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 8, [0x67, 0x3A, 0x5C, 0x80], [0x06, 0x90], [0x00, 0xB4], 1, [0x04, 0xE2], 45

字節拆分說明:
- 絕對時間戳 1732176000: [0x67, 0x3A, 0x5C, 0x80] (4字節，無符號32位)
- 充電電壓 1680: [0x06, 0x90] (2字節，無符號16位)
- 充電電流 180: [0x00, 0xB4] (2字節，無符號16位)
- 充電狀態 1: 1 (1字節)
- 已充入容量 1250: [0x04, 0xE2] (2字節，無符號16位)
- 預計充滿時間 45: 45 (1字節)

解讀: UAV→中控, 指令8, 時間=2025-11-21 12:00:00, 電壓=16.80V, 電流=1.80A, 充電中, 已充1250mAh, 預計45分鐘充滿
```

---

### 指令類型 9-10: 系統狀態

#### 指令 9: 系統負載
**頻率**: 2 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 5 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | CPU佔用率 | 10進制 | % | 0 ~ 100 |
| 3 | 記憶體佔用率 | 10進制 | % | 0 ~ 100 |
| 4 | 磁碟佔用率 | 10進制 | % | 0 ~ 100 |
| 5 | 系統運行時間 | 10進制 | 秒 | 開機後運行時間 |

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 9, 12345678, 35, 42, 68, 12345

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 9, [0x00, 0xBC, 0x61, 0x4E], 35, 42, 68, [0x30, 0x39]

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- CPU佔用率 35: 35 (1字節)
- 記憶體佔用率 42: 42 (1字節)
- 磁碟佔用率 68: 68 (1字節)
- 系統運行時間 12345: [0x30, 0x39] (2字節，無符號16位)

解讀: UAV→中控, 指令9, CPU=35%, 記憶體=42%, 磁碟=68%, 運行時間=12345秒
```

---

#### 指令 10: 視覺影像狀態
**頻率**: 1 Hz  
**時間戳**: 開機時間戳  
**數據長度**: 5 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 相機在線狀態 | 10進制 | - | 0=離線, 1=在線 |
| 3 | 錄影狀態 | 10進制 | - | 0=未錄影, 1=錄影中 |
| 4 | 解析度 | 10進制 | - | 0=480p, 1=720p, 2=1080p, 3=4K |
| 5 | 幀率 | 10進制 | fps | 影像幀率 |

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 10, 12345678, 1, 1, 2, 30

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 10, [0x00, 0xBC, 0x61, 0x4E], 1, 1, 2, 30

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 相機在線狀態 1: 1 (1字節)
- 錄影狀態 1: 1 (1字節)
- 解析度 2: 2 (1字節)
- 幀率 30: 30 (1字節)

解讀: UAV→中控, 指令10, 相機在線, 錄影中, 1080p, 30fps
```

---

## 📥 中控 → 載具（控制命令）

### 指令類型 11-13: 基礎控制

#### 指令 11: 武裝/解除武裝
**觸發**: 用戶操作  
**數據長度**: 2 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 武裝指令 | 10進制 | - | 0=解除武裝, 1=武裝 |
| 2 | 強制標誌 | 10進制 | - | 0=正常檢查, 1=強制執行（跳過安全檢查）|

**範例數據包**:
```
0xFF, 1, 2, 11, 1, 0
解讀: 中控→UAV, 指令11, 武裝, 正常檢查
```

---

#### 指令 12: 切換運作模式
**觸發**: 用戶操作  
**數據長度**: 2 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 模式代碼 | 10進制 | - | 見運作模式代碼表（指令1）|
| 2 | 子模式 | 10進制 | - | 0=標準, 1=跟隨UAV, 2=跟隨UGV（跟隨模式專用）|

**範例數據包**:
```
0xFF, 1, 2, 12, 2, 0
解讀: 中控→UAV, 指令12, 切換至導航模式, 標準
```

---

#### 指令 13: 設定Home Point
**觸發**: 用戶操作  
**數據長度**: 4 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 使用當前位置 | 10進制 | - | 0=使用下列座標, 1=使用當前位置 |
| 2 | 緯度 | 10進制 | 度×10000000 | Home點緯度（編碼值=實際值+900000000，範圍0~1800000000）|
| 3 | 經度 | 10進制 | 度×10000000 | Home點經度（有符號32位，使用二補數，範圍太大無法用偏移量）|
| 4 | 高度 | 10進制 | 公尺×100 | Home點高度 |

**範例數據包**:
```
數值表示: 0xFF, 1, 2, 13, 0, 1140240870, 1206468540, 10000

字節序列（實際傳輸，大端序）:
0xFF, 1, 2, 13, 0, [0x43, 0xF0, 0x5E, 0x26], [0x47, 0xE5, 0xF1, 0xBC], [0x27, 0x10]

字節拆分說明:
- 使用當前位置 0: 0 (1字節)
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 1206468540: [0x47, 0xE5, 0xF1, 0xBC] (4字節，有符號32位，二補數編碼，正數)
  實際經度 = 1206468540 ÷ 10000000 = 120.646854°（東經）
- 高度 10000: [0x27, 0x10] (2字節，無符號16位)

解讀: 中控→UAV, 指令13, 使用指定座標, 緯度=24.024087°N, 經度=120.646854°E, 高度=100.00m

**注意**：經度使用二補數編碼（有符號32位），是唯一使用二補數的數據類型。
```

---

### 指令類型 14-16: 任務規劃

#### 指令 14: 設定航點
**觸發**: 用戶操作  
**時間戳**: 無需時間戳（命令立即執行）  
**數據長度**: 8 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 航點序號 | 10進制 | - | 0開始，第幾個航點 |
| 2 | 緯度 | 10進制 | 度×10000000 | 航點緯度（編碼值=實際值+900000000，範圍0~1800000000）|
| 3 | 經度 | 10進制 | 度×10000000 | 航點經度（有符號32位，使用二補數，範圍太大無法用偏移量）|
| 4 | 高度 | 10進制 | 公尺×100 | 航點高度（無符號16位）|
| 5 | 速度 | 10進制 | m/s×100 | 飛行速度（0=使用預設，無符號16位）|
| 6 | 停留時間 | 10進制 | 秒 | 到達後停留秒數（0=不停留，無符號8位）|
| 7 | 動作類型 | 10進制 | - | 0=經過, 1=停留, 2=拍照, 3=降落（無符號8位）|
| 8 | 保留欄位 | 10進制 | - | 保留供未來使用（填0，無符號8位）|

**範例數據包**:
```
數值表示: 0xFF, 1, 2, 14, 0, 1140240870, 1206468540, 5000, 500, 0, 0, 0

字節序列（實際傳輸，大端序）:
0xFF, 1, 2, 14, 0, [0x43, 0xF0, 0x5E, 0x26], [0x47, 0xE5, 0xF1, 0xBC], [0x13, 0x88], [0x01, 0xF4], 0, 0, 0

字節拆分說明:
- 航點序號 0: 0 (1字節)
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 1206468540: [0x47, 0xE5, 0xF1, 0xBC] (4字節，有符號32位，二補數編碼，正數)
  實際經度 = 1206468540 ÷ 10000000 = 120.646854°（東經）
- 高度 5000: [0x13, 0x88] (2字節，無符號16位)
- 速度 500: [0x01, 0xF4] (2字節，無符號16位)
- 停留時間 0: 0 (1字節)
- 動作類型 0: 0 (1字節)
- 保留欄位 0: 0 (1字節)

解讀: 中控→UAV, 指令14, 航點0, 座標(24.024087°N, 120.646854°E), 高度50m, 速度5m/s, 經過

**注意**：經度使用二補數編碼（有符號32位），是唯一使用二補數的數據類型。
```

**使用說明**:
- 每次只能設定一個航點，需要設定多個航點時，分批次發送指令14
- 中控按航點序號（0, 1, 2, ...）逐個發送指令14
- 載具收到每個航點後，應回應指令18（確認）表示接收成功
- 如果載具回應失敗，中控應重發該航點
- 所有航點設定完成後，發送指令15（開始任務）開始執行
- 載具收到新的指令14時，會將該航點添加到任務列表中（不清除之前的航點）

---

#### 指令 15: 任務控制
**觸發**: 用戶操作  
**數據長度**: 1 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 任務動作 | 10進制 | - | 0=開始任務, 1=暫停任務, 2=繼續任務, 3=清除任務, 4=返航 |

**範例數據包**:
```
0xFF, 1, 2, 15, 0
解讀: 中控→UAV, 指令15, 開始執行任務
```

---

#### 指令 16: 即時導航至目標點
**觸發**: 地圖點擊  
**說明**: 在GUIDED模式下直接飛往指定座標  
**數據長度**: 4 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 緯度 | 10進制 | 度×10000000 | 目標緯度（編碼值=實際值+900000000，範圍0~1800000000）|
| 2 | 經度 | 10進制 | 度×10000000 | 目標經度（有符號32位，使用二補數，範圍太大無法用偏移量）|
| 3 | 高度 | 10進制 | 公尺×100 | 目標高度 |
| 4 | 速度 | 10進制 | m/s×100 | 飛行速度（0=使用預設）|

**範例數據包**:
```
數值表示: 0xFF, 1, 2, 16, 1140240870, 1206468540, 5000, 500

字節序列（實際傳輸，大端序）:
0xFF, 1, 2, 16, [0x43, 0xF0, 0x5E, 0x26], [0x47, 0xE5, 0xF1, 0xBC], [0x13, 0x88], [0x01, 0xF4]

字節拆分說明:
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 1206468540: [0x47, 0xE5, 0xF1, 0xBC] (4字節，有符號32位，二補數編碼，正數)
  實際經度 = 1206468540 ÷ 10000000 = 120.646854°（東經）
- 高度 5000: [0x13, 0x88] (2字節，無符號16位)
- 速度 500: [0x01, 0xF4] (2字節，無符號16位)

解讀: 中控→UAV, 指令16, 導航至座標(24.024087°N, 120.646854°E), 高度50m, 速度5m/s

**注意**：經度使用二補數編碼（有符號32位），是唯一使用二補數的數據類型。
```

---

### 指令類型 17: 載具間通訊

#### 指令 17: 廣播載具位置（協同作業）
**頻率**: 5 Hz（協同作業時）  
**時間戳**: 開機時間戳  
**數據長度**: 5 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 載具ID | 10進制 | - | 來源載具的ID |
| 3 | 緯度 | 10進制 | 度×10000000 | 載具當前緯度（編碼值=實際值+900000000，範圍0~1800000000）|
| 4 | 經度 | 10進制 | 度×10000000 | 載具當前經度（有符號32位，使用二補數，範圍太大無法用偏移量）|
| 5 | 高度 | 10進制 | 公尺×100 | 載具當前高度 |

**範例數據包**:
```
數值表示: 0xFF, 1, 255, 17, 12345678, 3, 1140240870, 1206468540, 500

字節序列（實際傳輸，大端序）:
0xFF, 1, 255, 17, [0x00, 0xBC, 0x61, 0x4E], 3, [0x43, 0xF0, 0x5E, 0x26], [0x47, 0xE5, 0xF1, 0xBC], [0x01, 0xF4]

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 載具ID 3: 3 (1字節)
- 緯度 1140240870: [0x43, 0xF0, 0x5E, 0x26] (4字節，無符號32位，偏移量編碼)
  實際緯度 = (1140240870 - 900000000) ÷ 10000000 = 24.024087°（北緯）
- 經度 1206468540: [0x47, 0xE5, 0xF1, 0xBC] (4字節，有符號32位，二補數編碼，正數)
  實際經度 = 1206468540 ÷ 10000000 = 120.646854°（東經）
- 高度 500: [0x01, 0xF4] (2字節，無符號16位)

解讀: 中控→全部載具(廣播), 指令17, UGV(3)位置, 座標(24.024087°N, 120.646854°E), 高度=5.00m

**注意**：經度使用二補數編碼（有符號32位），是唯一使用二補數的數據類型。
```

**使用場景**: UAV跟隨UGV時，中控定期廣播UGV位置給UAV

---

## 📋 載具回應與確認

### 指令類型 18: 回應

#### 指令 18: 命令執行確認
**觸發**: 收到控制命令後  
**時間戳**: 開機時間戳  
**數據長度**: 4 個欄位

| 順序 | 欄位 | 類型 | 單位 | 說明 |
|-----|------|------|------|------|
| 1 | 開機時間戳 | 10進制 | 毫秒 | 開機後經過時間 |
| 2 | 原始指令類型 | 10進制 | - | 回應的是哪個指令 |
| 3 | 執行結果 | 10進制 | - | 0=成功, 1=失敗, 2=執行中, 3=拒絕 |
| 4 | 錯誤代碼 | 10進制 | - | 失敗時的錯誤原因（見錯誤代碼表）|

**錯誤代碼表**:
- 0 = 無錯誤
- 1 = 參數無效
- 2 = 未武裝（需要先武裝）
- 3 = 模式不支援
- 4 = GPS未定位
- 5 = 電池電量不足
- 6 = 安全檢查失敗
- 7 = 通訊超時
- 255 = 未知錯誤

**範例數據包**:
```
數值表示: 0xFF, 2, 1, 18, 12345678, 11, 0, 0

字節序列（實際傳輸，大端序）:
0xFF, 2, 1, 18, [0x00, 0xBC, 0x61, 0x4E], 11, 0, 0

字節拆分說明:
- 時間戳 12345678: [0x00, 0xBC, 0x61, 0x4E] (4字節，無符號32位)
- 原始指令類型 11: 11 (1字節)
- 執行結果 0: 0 (1字節)
- 錯誤代碼 0: 0 (1字節)

解讀: UAV→中控, 指令18, 時間戳, 回應指令11(武裝), 成功, 無錯誤
```

---

## 📊 數據格式總結表

### 時間戳使用規則

| 指令類型 | 時間戳類型 | 理由 |
|---------|----------|------|
| 系統狀態、姿態、運動、GPS、高度 | 開機時間戳 | 用於實時圖表、姿態同步 |
| 充電狀態 | 絕對時間戳 | 需要記錄實際日期時間 |
| 電池、系統負載、視覺狀態 | 開機時間戳 | 實時監控數據 |
| 命令確認 | 開機時間戳 | 即時響應 |
| 控制命令（11-16） | 無需時間戳 | 命令立即執行 |
| 位置廣播 | 開機時間戳 | 實時協同數據 |

---

### 數據單位換算表

#### 直接存儲數據（無偏移量）

| 數據類型 | 存儲格式 | 實際值計算 | 範例 |
|---------|---------|-----------|------|
| Yaw角度 | 度×100 | 存儲值 ÷ 100 | 18000 → 180.00° |
| 速度 | m/s×100 | 存儲值 ÷ 100 | 320 → 3.20 m/s |
| 高度 | 公尺×100 | 存儲值 ÷ 100 | 15020 → 150.20 m |
| 電壓 | 伏特×100 | 存儲值 ÷ 100 | 1540 → 15.40 V |
| 溫度 | 攝氏度×10 | 存儲值 ÷ 10 | 350 → 35.0°C |
| HDOP | ×100 | 存儲值 ÷ 100 | 70 → 0.70 |

#### 偏移量編碼數據（需先減偏移量）

| 數據類型 | 存儲格式 | 偏移量 | 實際值計算 | 範例 |
|---------|---------|--------|-----------|------|
| Roll角度 | 度×100 | 18000 | (存儲值 - 18000) ÷ 100 | 17480 → -5.20° |
| Pitch角度 | 度×100 | 9000 | (存儲值 - 9000) ÷ 100 | 9310 → 3.10° |
| 角速度 | 度/秒×100 | 1000 | (存儲值 - 1000) ÷ 100 | 1010 → 0.10°/s |
| 緯度 | 度×10000000 | 900000000 | (存儲值 - 900000000) ÷ 10000000 | 1140240870 → 24.024087° |
| 垂直速度 | m/s×100 | 1000 | (存儲值 - 1000) ÷ 100 | 970 → -0.30 m/s |
| 電流 | 安培×100 | 1000 | (存儲值 - 1000) ÷ 100 | 1250 → 2.50 A |

**注意**：
- 經度使用有符號32位整數（二補數），不使用偏移量，直接解讀為有符號數值後除以10000000
- 範例：1206468540 → 120.646854°E，-1206468540 → -120.646854°（120.646854°W）

---

### 指令類型索引

| 指令編號 | 用途 | 方向 |
|---------|------|------|
| 1-6 | 基礎狀態（系統、姿態、運動、GPS、高度、爬升率）| 載具→中控 |
| 7-8 | 電源狀態（電池、充電）| 載具→中控 |
| 9-10 | 系統狀態（負載、視覺）| 載具→中控 |
| 11-13 | 基礎控制（武裝、模式、Home Point）| 中控→載具 |
| 14-16 | 任務規劃（航點設定、任務控制、導航）| 中控→載具 |
| 17 | 載具間通訊（位置廣播）| 中控→載具（廣播）|
| 18 | 回應確認（命令確認）| 載具→中控 |

---

## 🔍 數據包驗證機制

### 方法：校驗和 + 數據長度雙重驗證

本協議使用簡單的8位校驗和與數據長度驗證，確保數據包完整性：

**驗證步驟**:
1. 讀取起始標識（0xFF）
2. 讀取來源ID、目標ID
3. **讀取指令類型**
4. **根據指令類型查表，確定應有的數據長度**
5. **讀取實際數據內容**
6. **讀取校驗和（最後一個字節）**
7. **重新計算校驗和並比對**
8. **比對實際接收到的欄位數量是否符合預期**
9. **兩項驗證都通過才接受數據包**

**驗證規則表**:

| 指令類型 | 預期欄位數 | 驗證方式 |
|---------|----------|---------|
| 1 | 4 個 | 固定長度 |
| 2 | 7 個 | 固定長度 |
| 3 | 5 個 | 固定長度 |
| 4 | 7 個 | 固定長度 |
| 5 | 2 個 | 固定長度 |
| 6 | 2 個 | 固定長度 |
| 7 | 5 個 | 固定長度 |
| 8 | 6 個 | 固定長度 |
| 9 | 5 個 | 固定長度 |
| 10 | 5 個 | 固定長度 |
| 11 | 2 個 | 固定長度 |
| 12 | 2 個 | 固定長度 |
| 13 | 4 個 | 固定長度 |
| 14 | 8 個 | 固定長度 |
| 15 | 1 個 | 固定長度 |
| 16 | 4 個 | 固定長度 |
| 17 | 5 個 | 固定長度 |
| 18 | 4 個 | 固定長度 |

**範例驗證程式碼邏輯** (偽代碼):
```python
def verify_packet(packet):
    """驗證數據包"""
    # 1. 檢查最小包長
    if len(packet) < 5:  # 至少需要：起始+來源+目標+指令+校驗和
        return False
    
    # 2. 檢查起始標識
    if packet[0] != 0xFF:
        return False
    
    # 3. 提取指令類型
    source_id = packet[1]
    target_id = packet[2]
    cmd_type = packet[3]
    
    # 4. 根據指令類型查表，確定應有的數據長度
    expected_fields = {
        1: 4, 2: 7, 3: 5, 4: 7, 5: 2, 6: 2,
        7: 5, 8: 6, 9: 5, 10: 5,
        11: 2, 12: 2, 13: 4, 14: 8,
        15: 1, 16: 4, 17: 5, 18: 4
    }
    
    expected_data_length = expected_fields.get(cmd_type, -1)
    if expected_data_length == -1:
        return False  # 未知指令類型
    
    # 5. 驗證數據長度（包含校驗和）
    expected_total_length = 4 + expected_data_length + 1  # 起始+來源+目標+指令+數據+校驗和
    if len(packet) != expected_total_length:
        return False  # 數據長度不符
    
    # 6. 驗證校驗和
    received_checksum = packet[-1]  # 最後一個字節是校驗和
    calculated_checksum = 0
    
    # 計算校驗和（從來源ID到數據內容的最後一個字節）
    for i in range(1, len(packet) - 1):  # 跳過起始標識和校驗和
        calculated_checksum += packet[i]
    calculated_checksum &= 0xFF  # 取低8位
    
    if received_checksum != calculated_checksum:
        return False  # 校驗和錯誤
    
    # 7. 驗證通過
    return True
```

**優點**:
- ✅ 算力要求極低（簡單加法運算）
- ✅ 可檢測數據包截斷、數據遺失、單字節錯誤
- ✅ 可檢測指令類型錯誤
- ✅ 實現簡單（幾行代碼）
- ✅ 校驗和僅1字節，開銷小
- ✅ 雙重驗證（校驗和+長度）提高可靠性

**限制**:
- ⚠️ 無法檢測字節順序交換
- ⚠️ 無法檢測多個錯誤互相抵消的情況（機率極低）
- ⚠️ 適合穩定通訊環境
- ⚠️ 不如CRC16精確，但算力要求低得多

---

## 💡 使用建議

### 1. 頻率控制
建議根據實際需求調整發送頻率：
- **高頻數據**（20Hz）: 姿態數據
- **中頻數據**（10Hz）: 運動數據、高度數據、爬升率
- **低頻數據**（1-5Hz）: GPS、電池、系統狀態
- **事件觸發**: 命令確認

### 2. 重複前一個指令包
當無新數據時，可重複發送前一個指令包以維持連線：
- 例如：系統狀態（指令1）每秒發送，可替代心跳包功能
- 重複發送最近的指令包可確保中控知道載具仍在線

### 3. 連線監控
- 中控監控載具數據包，超過3秒未收到任何數據則標記為離線
- 建議載具至少每秒發送一次系統狀態（指令1）

### 4. 數據優先級
在頻寬受限時，優先發送：
1. 系統狀態（指令1）
2. GPS定位（指令4）
3. 電池狀態（指令7）
4. 姿態數據（指令2）
5. 其他數據

---

## 📝 版本記錄

**v1.6** (2025-11-21)
- 優化數據單位換算表，區分直接存儲和偏移量編碼數據
- 為偏移量編碼數據補充偏移量欄位和解碼公式
- 修正指令7電流範例，改為放電範例（編碼值1250，實際值2.50A）
- 修正指令4緯度說明，統一使用偏移量編碼公式，明確標註編碼值和實際值
- 更新所有包含緯度的指令範例（指令4、13、14、16、17），使用正確的編碼值
- 補充負數經度完整範例，展示二補數編碼（指令4）

**v1.5** (2025-11-21)
- 修正校驗和計算範例，明確說明按字節相加（不是按數值相加）
- 添加字節拆分規則章節，說明多字節數據如何拆分為字節
- 在所有關鍵範例中添加字節序列說明（指令2、4、6、13、14、16、17）
- 明確說明經度是唯一使用二補數編碼的數據類型（方案A）
- 補充完整的校驗和計算範例，展示字節級別的計算過程

**v1.4** (2025-11-21)
- 負數編碼改為偏移量法（Offset/Bias），統一使用10進制表示
- 避免二補數法造成的十進制/十六進制混用問題
- 所有負數數據（除經度外）使用偏移量編碼
- 經度範圍太大，仍使用有符號32位整數（二補數）
- 更新所有範例數據包，統一使用10進制表示

**v1.3** (2025-11-21)
- 指令14改為固定長度（8個欄位），每次只設定一個航點
- 刪除批量設定航點功能，改為分批次發送方式
- 所有指令均為固定長度，簡化驗證邏輯
- 更新驗證規則表和驗證程式碼

**v1.2** (2025-11-21)
- 添加數據編碼規範章節
- 明確規定使用二補數（Two's Complement）表示負數
- 明確規定使用大端序（Big-Endian）字節序
- 添加數據類型對照表（字節數、符號性、範圍）
- 添加編碼/解碼範例代碼（Python、C/C++）
- 更新範例數據包，標註負數的二補數編碼

**v1.1** (2025-11-21)
- 重新編號指令，確保連續不跳號（1-18）
- 刪除指令17（查詢航點資訊）
- 指令14改為批量發送航點模式（可變長度）（已在v1.3改回固定長度）
- 指令11（原12）→ 武裝/解除武裝
- 指令12（原13）→ 切換運作模式
- 指令13（原14）→ 設定Home Point
- 指令14（原15）→ 批量設定航點（可變長度）
- 指令15（原16）→ 任務控制
- 指令16（原18）→ 即時導航至目標點
- 指令17（原19）→ 廣播載具位置
- 指令18（原20）→ 命令執行確認

**v1.0** (2025-11-21)
- 初始版本
- 定義裝置ID（1=中控, 2=UAV, 3=UGV, 255=廣播）
- 定義指令類型1-20（連續編號，移除指令10、21、22）（已更新為v1.1的1-18）
- 所有指令添加數據長度欄位
- 所有指令均為固定長度（簡化驗證）
- 添加8位校驗和機制（簡單累加，算力要求低）
- 區分絕對時間戳與開機時間戳
- 簡化設計：無CRC、無結束標識、無RC Override、無可變長度指令（所有指令均為固定長度）

---

**文檔維護**: 專案團隊  
**最後更新**: 2025-11-21

